<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç‰©ç†ç”µè·¯å®éªŒ</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        :root {
            --grid-size: 20px;
            --primary-color: #0d6efd;
            --wire-color: #333;
            --canvas-bg: #f8f9fa;
        }
        body {
            overscroll-behavior-y: none;
            touch-action: pan-x pan-y;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            display: flex;
            flex-direction: column;
            height: 100dvh;
            margin: 0;
            background-color: #e9ecef;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        /* é¡¶éƒ¨å¯¼èˆªä¸æ§åˆ¶åŒº */
        .header-area {
            background: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            z-index: 10;
            padding: 10px;
        }
        /* å…ƒä»¶åº“æ°´å¹³æ»šåŠ¨åŒº */
        .component-palette {
            display: flex;
            overflow-x: auto;
            white-space: nowrap;
            padding: 10px;
            background: #fff;
            border-bottom: 1px solid #ddd;
            gap: 10px;
            -webkit-overflow-scrolling: touch;
        }
        .palette-item {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 70px;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
            touch-action: pan-x;
        }
        .palette-item:active { background-color: #e9ecef; }
        .palette-item svg { width: 40px; height: 40px; margin-bottom: 5px; pointer-events: none; }
        .palette-item span { font-size: 12px; color: #495057; pointer-events: none; }
        
        /* æ ¸å¿ƒç”»å¸ƒåŒº */
        .canvas-container {
            flex: 1;
            position: relative;
            background-color: var(--canvas-bg);
            background-image:
                linear-gradient(to right, #ddd 1px, transparent 1px),
                linear-gradient(to bottom, #ddd 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            background-position: 0 0;
            overflow: hidden;
            touch-action: none;
        }
        .canvas-wrapper {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            transition: none;
        }
        #circuit-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* åƒåœ¾æ¡¶åŒº */
        .trash-can {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            background-color: rgba(220, 53, 69, 0.15);
            color: #dc3545;
            border: 2px dashed #dc3545;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: all 0.2s ease;
            opacity: 0;
            pointer-events: none;
            transform: scale(0.8);
        }
        .trash-can.visible {
            opacity: 1;
            transform: scale(1);
        }
        .trash-can.active {
            transform: scale(1.2);
            background-color: #dc3545;
            color: #fff;
            border-style: solid;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }

        /* ç»ƒä¹ ä»»åŠ¡æµ®çª— */
        #practice-panel {
            pointer-events: auto;
        }
        #practice-panel button, #practice-panel select {
            pointer-events: auto;
        }

        /* SVG æ ·å¼ */
        .wire { stroke: var(--wire-color); stroke-width: 3; fill: none; stroke-linejoin: round; cursor: pointer; transition: stroke 0.3s; }
        .wire:hover { stroke: #dc3545; }
        .wire-click-area { stroke: transparent; stroke-width: 20; fill: none; cursor: pointer; }
        
        .component-group { cursor: grab; }
        .component-group:active { cursor: grabbing; }
        .terminal { fill: #dc3545; stroke: #fff; stroke-width: 2; cursor: crosshair; transition: r 0.2s; }
        .terminal.negative { fill: #0dcaf0; }
        .terminal:hover, .terminal.active { r: 8; stroke: #ffc107; stroke-width: 3; }
        
        /* ç¯æ³¡å‘å…‰æ•ˆæœ */
        .bulb-glass { fill: #fff; transition: all 0.3s ease; }
        .bulb-cross { stroke: #333; transition: all 0.3s ease; }
        .bulb-glass.active {
            fill: #fff9c4;
            filter: drop-shadow(0 0 8px #ffeb3b);
            stroke: #fbc02d;
        }
        .bulb-cross.active { stroke: #fbc02d; }

        /* çŠ¶æ€ä¸æ§åˆ¶æ  */
        .footer-area {
            background: #fff;
            padding: 10px;
            border-top: 1px solid #ddd;
            z-index: 10;
        }
        .status-box {
            font-size: 14px;
            font-weight: bold;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        .status-idle { background: #e9ecef; color: #495057; }
        .status-success { background: #d1e7dd; color: #0f5132; }
        .status-error { background: #f8d7da; color: #842029; }
    </style>
</head>
<body>

    <!-- é¡¶éƒ¨æ§åˆ¶åŒº -->
    <div class="header-area d-flex justify-content-between align-items-center">
        <h5 class="m-0 text-truncate" style="max-width: 20%;">ç‰©ç†ç”µè·¯å®éªŒ</h5>
        <div class="d-flex gap-2">
            <select class="form-select form-select-sm" id="scene-select">
                <option value="class">è¯¾ä¸­æ¼”ç¤º</option>
                <option value="practice">è¯¾åç»ƒä¹ </option>
            </select>
            <select class="form-select form-select-sm" id="mode-select">
                <option value="basic">åŸºç¡€æ­å»º</option>
                <option value="fault">æ•…éšœæ¨¡æ‹Ÿ</option>
            </select>
        </div>
    </div>

    <!-- æ•…éšœæ¨¡æ‹Ÿä¸“åŒº -->
    <div id="fault-panel" class="bg-light px-2 py-2 border-bottom d-none">
        <div class="d-flex align-items-center justify-content-between gap-2">
            <span style="font-size: 13px; white-space: nowrap;">æ¤å…¥æ•…éšœ:</span>
            <select class="form-select form-select-sm" id="fault-type">
                <option value="none">æ— æ•…éšœ (è‡ªåŠ¨è¯†åˆ«)</option>
                <option value="power_short">ç”µæºçŸ­è·¯</option>
                <option value="appliance_short">ç”¨ç”µå™¨çŸ­è·¯</option>
                <option value="wire_break">å¯¼çº¿æ–­è·¯</option>
                <option value="range_error">é‡ç¨‹é€‰é”™</option>
            </select>
            <button style="width: 80px;" class="btn btn-sm btn-outline-danger" id="btn-trigger-fault">è§¦å‘</button>
        </div>
    </div>

    <!-- ç‰©ç†åŸç†å›¾ç¬¦å·åº“ -->
    <div class="component-palette" id="palette">
        <div class="palette-item" data-type="battery">
            <svg viewBox="0 0 60 40">
                <path d="M 5 20 L 25 20 M 25 10 L 25 30 M 35 15 L 35 25 M 35 20 L 55 20" stroke="#333" stroke-width="2"/>
                <path d="M 35 15 L 35 25" stroke="#333" stroke-width="4"/>
                <text x="12" y="15" font-size="12">+</text>
                <text x="42" y="15" font-size="12">-</text>
            </svg>
            <span>ç”µæº</span>
        </div>
        <div class="palette-item" data-type="bulb">
            <svg viewBox="0 0 60 60">
                <circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/>
                <path d="M 19 19 L 41 41 M 19 41 L 41 19" stroke="#333" stroke-width="2"/>
                <path d="M 5 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>
            </svg>
            <span>ç¯æ³¡</span>
        </div>
        <div class="palette-item" data-type="resistor">
            <svg viewBox="0 0 60 40">
                <rect x="15" y="15" width="30" height="10" fill="#fff" stroke="#333" stroke-width="2"/>
                <path d="M 5 20 L 15 20 M 45 20 L 55 20" stroke="#333" stroke-width="2"/>
                <text x="30" y="12" font-size="10" text-anchor="middle">10Î©</text>
            </svg>
            <span>å®šå€¼ç”µé˜»</span>
        </div>
        <div class="palette-item" data-type="switch">
            <svg viewBox="0 0 60 40">
                <path d="M 5 20 L 20 20 M 40 20 L 55 20" stroke="#333" stroke-width="2"/>
                <circle cx="20" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/>
                <circle cx="40" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/>
                <line x1="20" y1="20" x2="38" y2="10" stroke="#333" stroke-width="2"/>
            </svg>
            <span>å¼€å…³</span>
        </div>
        <div class="palette-item" data-type="ammeter">
            <svg viewBox="0 0 60 60">
                <circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/>
                <text x="30" y="35" font-size="14" font-weight="bold" text-anchor="middle">A</text>
                <path d="M 5 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>
            </svg>
            <span>ç”µæµè¡¨</span>
        </div>
        <div class="palette-item" data-type="voltmeter">
            <svg viewBox="0 0 60 60">
                <circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/>
                <text x="30" y="35" font-size="14" font-weight="bold" text-anchor="middle">V</text>
                <path d="M 5 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>
            </svg>
            <span>ç”µå‹è¡¨</span>
        </div>
    </div>

    <!-- å®éªŒç”»å¸ƒ -->
    <div class="canvas-container" id="canvas-container">
        
        <!-- è¯¾åç»ƒä¹ ä»»åŠ¡æµ®çª— (æ”¯æŒå¢åˆ æ”¹æŸ¥é€‰æ‹©) -->
        <div id="practice-panel" class="position-absolute top-0 end-0 m-3 p-3 bg-white border rounded shadow-sm d-none" style="z-index: 105; width: 320px;" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">
            
            <!-- æ™®é€šæŸ¥çœ‹æ¨¡å¼ -->
            <div id="practice-view-mode">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="text-primary m-0 fw-bold d-flex align-items-center gap-1">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"/></svg>
                        ç»ƒä¹ ä»»åŠ¡
                    </h6>
                    <button class="btn btn-sm btn-outline-primary py-0" style="font-size: 12px;" onclick="startCreatePractice()">åˆ›å»ºç»ƒä¹ </button>
                </div>
                
                <select class="form-select form-select-sm mb-2" id="practice-select" onchange="loadSelectedPractice()">
                    <!-- JS åŠ¨æ€å¡«å…… -->
                </select>
                
                <div class="p-2 bg-light border rounded mb-3" style="max-height: 80px; overflow-y: auto;">
                    <p class="small text-muted m-0" id="practice-task-desc">ä»»åŠ¡ç›®æ ‡åŠ è½½ä¸­...</p>
                </div>
                
                <div class="d-flex gap-2">
                    <button class="btn btn-sm btn-success flex-fill fw-bold shadow-sm" id="btn-submit-practice" onclick="verifyPractice()">æäº¤éªŒè¯</button>
                    <button class="btn btn-sm btn-outline-danger d-none" id="btn-delete-practice" onclick="deleteCurrentPractice()">åˆ é™¤æœ¬é¢˜</button>
                </div>
                <div id="practice-result" class="mt-2 small font-weight-bold text-center"></div>
            </div>

            <!-- åˆ›å»ºæ–°ç»ƒä¹ ç¼–è¾‘æ¨¡å¼ -->
            <div id="practice-edit-mode" class="d-none">
                <div class="d-flex align-items-center mb-2">
                    <h6 class="text-primary m-0 fw-bold d-flex align-items-center gap-1">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        åˆ›è®¾æ–°ç»ƒä¹ 
                    </h6>
                </div>
                <div class="p-2 bg-light border rounded mb-3">
                    <p class="small text-muted m-0">ç”»å¸ƒå·²æ¸…ç©ºã€‚è¯·åœ¨å·¦ä¾§æ‹–æ‹½æ‘†æ”¾æ‚¨æƒ³å‘ç»™å­¦ç”Ÿçš„**åˆå§‹å…ƒä»¶**ã€‚æ‘†æ”¾å®Œæˆåç‚¹å‡»ä¸‹æ–¹â€œç¡®å®šâ€è¿›è¡Œä¿å­˜ã€‚</p>
                </div>
                <div class="d-flex gap-2">
                    <button class="btn btn-sm btn-secondary flex-fill shadow-sm" onclick="cancelCreatePractice()">å–æ¶ˆå¹¶è¿”å›</button>
                    <button class="btn btn-sm btn-primary flex-fill fw-bold shadow-sm" onclick="showSaveTaskModal()">ç¡®å®šå¹¶ä¿å­˜</button>
                </div>
            </div>

        </div>

        <div class="canvas-wrapper" id="canvas-wrapper">
            <svg id="circuit-canvas">
                <!-- å¯¼çº¿å±‚ -->
                <g id="layer-wires"></g>
                <!-- å…ƒä»¶å±‚ -->
                <g id="layer-components"></g>
            </svg>
        </div>
        
        <!-- åˆ é™¤åƒåœ¾æ¡¶ -->
        <div id="trash-can" class="trash-can">
            <svg viewBox="0 0 24 24" width="28" height="28" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
        </div>
    </div>

    <!-- åº•éƒ¨æ§åˆ¶åŒº -->
    <div class="footer-area">
        <div id="status-display" class="status-box status-idle">ç­‰å¾…æ“ä½œ (æœªè¿æ¥ç”µæº)</div>
        <div class="d-flex justify-content-between gap-2">
            <button class="btn btn-secondary flex-fill" onclick="showGuide()">æ“ä½œæŒ‡å—</button>
            <button class="btn btn-danger flex-fill" onclick="resetCanvas()">é‡ç½®ç”»å¸ƒ</button>
            <button class="btn btn-primary flex-fill" id="btn-simulate" onclick="toggleSimulation()">å¯åŠ¨å®éªŒ</button>
        </div>
    </div>

    <!-- 3æ­¥æ“ä½œæŒ‡å— Modal -->
    <div class="modal fade" id="guideModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">ç®€å•ä¸‰æ­¥æ“ä½œæŒ‡å—</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                    <h6>ç¬¬ä¸€æ­¥ï¼šæ·»åŠ ä¸æ‘†æ”¾</h6>
                    <p class="text-muted small"><strong>é•¿æŒ‰æˆ–æ‹–æ‹½</strong>é¡¶éƒ¨å…ƒä»¶åº“ä¸­çš„å…ƒä»¶ï¼Œç§»åŠ¨è‡³ç”»å¸ƒæ¾æ‰‹ã€‚<br>æ‹–å…¥å³ä¸‹è§’<strong>åƒåœ¾æ¡¶</strong>å¯å°†å…¶åˆ é™¤ã€‚</p>
                    <hr>
                    <h6>ç¬¬äºŒæ­¥ï¼šæ‹–æ‹½è¿çº¿</h6>
                    <p class="text-muted small"><strong>æŒ‰ä½</strong>å…ƒä»¶ä¸¤ç«¯çš„å¼•è„šèŠ‚ç‚¹ï¼Œæ‹–åŠ¨è¿›è¡Œè¿çº¿ã€‚ç‚¹å‡»å·²è¿å¥½çš„å¯¼çº¿å¯å°†å…¶åˆ é™¤ã€‚</p>
                    <hr>
                    <h6>ç¬¬ä¸‰æ­¥ï¼šå¯åŠ¨ä¸è¯Šæ–­</h6>
                    <p class="text-muted small">ç¡®ä¿ç”µè·¯é—­åˆåï¼Œç‚¹å‡»â€œå¯åŠ¨å®éªŒâ€ï¼Œè§‚å¯Ÿç¯æ³¡å‘å…‰æˆ–åº•éƒ¨çŠ¶æ€æ çš„æ•…éšœæç¤ºã€‚</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary w-100" data-bs-dismiss="modal">æˆ‘çŸ¥é“äº†</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ä¿å­˜ç»ƒä¹  Modal -->
    <div class="modal fade" id="saveTaskModal" tabindex="-1" aria-hidden="true" style="z-index: 1060;">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">ä¿å­˜ä¸ºè‡ªå®šä¹‰ç»ƒä¹ </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label class="form-label">ç»ƒä¹ åç§°</label>
                        <input type="text" class="form-control" id="task-name-input" placeholder="ä¾‹å¦‚ï¼šæˆ‘çš„å¹¶è”ç”µè·¯æµ‹è¯•">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">ä»»åŠ¡è¦æ±‚ / æè¿°</label>
                        <textarea class="form-control" id="task-desc-input" rows="3" placeholder="æè¿°å­¦ç”Ÿéœ€è¦å®Œæˆçš„ç›®æ ‡ï¼Œä¾‹å¦‚ï¼šè¯·è¿æ¥å¯¼çº¿ç‚¹äº®æ‰€æœ‰ç¯æ³¡..."></textarea>
                    </div>
                    <div class="text-muted small">
                        * å½“å‰ç”»å¸ƒä¸Šçš„æ‰€æœ‰å…ƒä»¶å’Œè¿çº¿å°†ä¼šè¢«ä¿å­˜ã€‚
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">å–æ¶ˆ</button>
                    <button type="button" class="btn btn-primary" onclick="saveCurrentPractice()">ç¡®è®¤ä¿å­˜</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        const canvas = document.getElementById('circuit-canvas');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvasContainer = document.getElementById('canvas-container');
        const layerWires = document.getElementById('layer-wires');
        const layerComps = document.getElementById('layer-components');
        const statusDisplay = document.getElementById('status-display');
        const trashCan = document.getElementById('trash-can');
        
        let components = [];
        let wires = [];
        let compCounter = 0;
        let isSimulating = false;
        let conductingWireIds = new Set();
        
        let draggingComp = null;
        let dragOffset = { x: 0, y: 0 };
        let isHoveringTrash = false;

        let tempWire = null; 
        let allPinsCache = [];
        
        let canvasScale = 1;
        let canvasOffset = { x: 0, y: 0 };
        let isDraggingCanvas = false;
        let canvasDragStart = { x: 0, y: 0 };
        let canvasDragStartOffset = { x: 0, y: 0 };
        
        const gridSize = 20;

        // ç»Ÿä¸€ä¸ºæ ‡å‡†ç‰©ç†åŸç†å›¾ç¬¦å·å®šä¹‰
        const CompDefs = {
            battery: {
                width: 60, height: 40, res: 0, type: 'source',
                svg: `<rect width="60" height="40" fill="transparent"/><path d="M 0 20 L 25 20 M 25 10 L 25 30 M 35 15 L 35 25 M 35 20 L 60 20" stroke="#333" stroke-width="2"/><path d="M 35 15 L 35 25" stroke="#333" stroke-width="4"/><text x="15" y="12" font-size="12">+</text><text x="40" y="12" font-size="12">-</text>`,
                pins: [{id: 'p1', x: 0, y: 20, type:'positive'}, {id: 'p2', x: 60, y: 20, type:'negative'}]
            },
            bulb: {
                width: 60, height: 60, res: 10, type: 'load',
                svg: `<rect width="60" height="60" fill="transparent"/><circle class="bulb-glass" cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/><path d="M 19 19 L 41 41 M 19 41 L 41 19" stroke="#333" stroke-width="2" class="bulb-cross"/><path d="M 0 30 L 15 30 M 45 30 L 60 30" stroke="#333" stroke-width="2"/>`,
                pins: [{id: 'p1', x: 0, y: 30}, {id: 'p2', x: 60, y: 30}]
            },
            resistor: {
                width: 60, height: 40, res: 10, type: 'load',
                svg: `<rect width="60" height="40" fill="transparent"/><rect x="15" y="15" width="30" height="10" fill="#fff" stroke="#333" stroke-width="2"/><path d="M 0 20 L 15 20 M 45 20 L 60 20" stroke="#333" stroke-width="2"/><text x="30" y="10" font-size="10" text-anchor="middle">10Î©</text>`,
                pins: [{id: 'p1', x: 0, y: 20}, {id: 'p2', x: 60, y: 20}]
            },
            switch: {
                width: 60, height: 40, res: 0, type: 'switch',
                svg: `<rect width="60" height="40" fill="transparent"/><path d="M 0 20 L 15 20 M 45 20 L 60 20" stroke="#333" stroke-width="2"/><circle cx="15" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/><circle cx="45" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/><line class="switch-blade" x1="15" y1="20" x2="40" y2="10" stroke="#333" stroke-width="2"/>`,
                pins: [{id: 'p1', x: 0, y: 20}, {id: 'p2', x: 60, y: 20}]
            },
            ammeter: {
                width: 60, height: 60, res: 0, type: 'meter',
                svg: `<rect width="60" height="60" fill="transparent"/><circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/><text x="30" y="35" font-size="14" font-weight="bold" text-anchor="middle">A</text><path d="M 0 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>`,
                pins: [{id: 'p1', x: 0, y: 30}, {id: 'p2', x: 60, y: 30}]
            },
            voltmeter: {
                width: 60, height: 60, res: 999999, type: 'meter',
                svg: `<rect width="60" height="60" fill="transparent"/><circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/><text x="30" y="35" font-size="14" font-weight="bold" text-anchor="middle">V</text><path d="M 0 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>`,
                pins: [{id: 'p1', x: 0, y: 30}, {id: 'p2', x: 60, y: 30}]
            }
        };

        function updateCanvasTransform() {
            canvasWrapper.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${canvasScale})`;
            const gridSizeScaled = gridSize * canvasScale;
            canvasContainer.style.backgroundSize = `${gridSizeScaled}px ${gridSizeScaled}px`;
            canvasContainer.style.backgroundPosition = `${canvasOffset.x}px ${canvasOffset.y}px`;
        }

        // ================= ç»ƒä¹ ä»»åŠ¡ç®¡ç† (å¢åˆ æ”¹æŸ¥) =================
        const STORE_KEY = 'circuit_custom_tasks';
        let allPractices = [];
        let lastSelectedPracticeId = null;

        function initPractices() {
            const defaults = [
                {
                    id: 'default_1',
                    name: 'åŸºç¡€ä¸²è”ç”µè·¯',
                    description: 'è¯·ä½¿ç”¨å·²æä¾›çš„ç”µæºã€å¼€å…³å’Œç¯æ³¡ï¼Œæ­å»ºä¸€ä¸ªåŸºæœ¬çš„é—­åˆä¸²è”ç”µè·¯ã€‚å®Œæˆåå¯åŠ¨å®éªŒå¹¶ç‚¹äº®ç¯æ³¡ï¼',
                    components: [
                        { id: 'comp_1', type: 'battery', x: 100, y: 180, isClosed: false },
                        { id: 'comp_2', type: 'switch', x: 280, y: 180, isClosed: false },
                        { id: 'comp_3', type: 'bulb', x: 200, y: 110, isClosed: false }
                    ],
                    wires: [],
                    isCustom: false
                },
                {
                    id: 'default_2',
                    name: 'å¹¶è”ç”µè·¯æŒ‘æˆ˜',
                    description: 'è¯·ä½¿ç”¨æä¾›çš„ç”µæºã€ä¸¤ä¸ªç¯æ³¡ã€ä¸¤ä¸ªå¼€å…³ã€‚ä½¿ä¸¤ä¸ªå¼€å…³åˆ†åˆ«ç‹¬ç«‹æ§åˆ¶ä¸¤ä¸ªç¯æ³¡ï¼ˆå¹¶è”å…³ç³»ï¼‰ã€‚',
                    components: [
                        { id: 'comp_1', type: 'battery', x: 80, y: 180, isClosed: false },
                        { id: 'comp_2', type: 'bulb', x: 280, y: 170, isClosed: false },
                        { id: 'comp_3', type: 'bulb', x: 280, y: 290, isClosed: false },
                        { id: 'comp_4', type: 'switch', x: 180, y: 180, isClosed: false },
                        { id: 'comp_5', type: 'switch', x: 180, y: 300, isClosed: false }
                    ],
                    wires: [],
                    isCustom: false
                }
            ];

            let customs = [];
            try {
                const saved = localStorage.getItem(STORE_KEY);
                if(saved) customs = JSON.parse(saved);
            } catch(e) {}

            allPractices = [...defaults, ...customs];
            
            const select = document.getElementById('practice-select');
            select.innerHTML = '';
            allPractices.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.innerText = (p.isCustom ? '[è‡ªå®šä¹‰] ' : '') + p.name;
                select.appendChild(opt);
            });
        }

        function loadSelectedPractice() {
            const id = document.getElementById('practice-select').value;
            const task = allPractices.find(p => p.id === id);
            if(!task) return;

            document.getElementById('practice-task-desc').innerText = task.description;
            document.getElementById('practice-result').innerText = '';
            
            const delBtn = document.getElementById('btn-delete-practice');
            if(task.isCustom) delBtn.classList.remove('d-none');
            else delBtn.classList.add('d-none');

            // æ¢å¤ç”»å¸ƒçŠ¶æ€
            resetSimulation();
            components = task.components.map(c => ({
                id: c.id,
                type: c.type,
                x: c.x,
                y: c.y,
                def: CompDefs[c.type],
                isClosed: c.isClosed || false
            }));
            wires = task.wires.map(w => ({...w}));
            
            // é‡æ–°è®¡ç®— ID è®¡æ•°å™¨é˜²æ­¢å†²çª
            let maxId = 0;
            components.forEach(c => {
                const num = parseInt(c.id.split('_')[1]);
                if(!isNaN(num) && num > maxId) maxId = num;
            });
            compCounter = maxId;

            // è§†è§’å½’ä¸­
            canvasOffset = {x: 0, y: 0};
            canvasScale = 1;
            updateCanvasTransform();
            
            renderComponents();
            renderWires();
            setStatus('idle', 'ç›®æ ‡ä»»åŠ¡æ¨¡å¼ï¼šè¯·æ ¹æ®æç¤ºè¿æ¥ç”µè·¯ã€‚');
        }

        // ================= åˆ›å»ºæ–°ç»ƒä¹ æµç¨‹ =================
        window.startCreatePractice = function() {
            lastSelectedPracticeId = document.getElementById('practice-select').value;
            document.getElementById('practice-view-mode').classList.add('d-none');
            document.getElementById('practice-edit-mode').classList.remove('d-none');
            resetCanvas(true);
            setStatus('idle', 'åˆ›è®¾æ–°ç»ƒä¹ ï¼šè¯·åœ¨ç”»å¸ƒä¸Šæ‘†æ”¾æ‰€éœ€å…ƒä»¶å’Œè¿çº¿...');
        };

        window.cancelCreatePractice = function() {
            document.getElementById('practice-edit-mode').classList.add('d-none');
            document.getElementById('practice-view-mode').classList.remove('d-none');
            if (lastSelectedPracticeId) {
                document.getElementById('practice-select').value = lastSelectedPracticeId;
                loadSelectedPractice();
            }
        };

        window.showSaveTaskModal = function() {
            new bootstrap.Modal(document.getElementById('saveTaskModal')).show();
        };

        window.saveCurrentPractice = function() {
            const name = document.getElementById('task-name-input').value.trim();
            const desc = document.getElementById('task-desc-input').value.trim();
            if(!name) return alert('è¯·è¾“å…¥ç»ƒä¹ åç§°');

            const savedComps = components.map(c => ({ id: c.id, type: c.type, x: c.x, y: c.y, isClosed: c.isClosed }));
            const savedWires = wires.map(w => ({ id: w.id, p1: w.p1, p2: w.p2 }));

            const newTask = {
                id: 'custom_' + Date.now(),
                name: name,
                description: desc || 'æ— è¯¦ç»†è¦æ±‚',
                components: savedComps,
                wires: savedWires,
                isCustom: true
            };

            let customs = [];
            try {
                const saved = localStorage.getItem(STORE_KEY);
                if(saved) customs = JSON.parse(saved);
            } catch(e) {}

            customs.push(newTask);
            localStorage.setItem(STORE_KEY, JSON.stringify(customs));

            bootstrap.Modal.getInstance(document.getElementById('saveTaskModal')).hide();
            document.getElementById('task-name-input').value = '';
            document.getElementById('task-desc-input').value = '';

            document.getElementById('practice-edit-mode').classList.add('d-none');
            document.getElementById('practice-view-mode').classList.remove('d-none');

            initPractices();
            document.getElementById('practice-select').value = newTask.id;
            loadSelectedPractice();
            alert('æˆåŠŸä¿å­˜ä¸ºè‡ªå®šä¹‰ç»ƒä¹ ï¼');
        };

        window.deleteCurrentPractice = function() {
            const id = document.getElementById('practice-select').value;
            const task = allPractices.find(p => p.id === id);
            if(!task || !task.isCustom) return;

            if(!confirm(`ç¡®å®šè¦åˆ é™¤è‡ªå®šä¹‰ç»ƒä¹  "${task.name}" å—ï¼Ÿ`)) return;

            let customs = [];
            try {
                const saved = localStorage.getItem(STORE_KEY);
                if(saved) customs = JSON.parse(saved);
            } catch(e) {}

            customs = customs.filter(c => c.id !== id);
            localStorage.setItem(STORE_KEY, JSON.stringify(customs));

            initPractices();
            loadSelectedPractice();
        };

        // é€šç”¨çš„æäº¤éªŒè¯é€»è¾‘
        window.verifyPractice = function() {
            const resultDiv = document.getElementById('practice-result');
            
            if(!isSimulating) {
                resultDiv.innerHTML = '<span class="text-warning">è¯·å…ˆç‚¹å‡»åº•éƒ¨â€œå¯åŠ¨å®éªŒâ€è®©ç”µè·¯è¿è¡Œï¼</span>';
                return;
            }

            if (statusDisplay.classList.contains('status-error') || statusDisplay.classList.contains('status-idle')) {
                resultDiv.innerHTML = '<span class="text-danger">ä»»åŠ¡å¤±è´¥ï¼šç”µè·¯å­˜åœ¨æ•…éšœã€çŸ­è·¯æˆ–æœªèƒ½è¿é€šã€‚</span>';
                return;
            }
            
            const bulbs = components.filter(c => c.type === 'bulb');
            if(bulbs.length > 0) {
                let allLit = true;
                bulbs.forEach(b => {
                    const compGroup = document.querySelector(`g[data-id="${b.id}"]`);
                    if(compGroup) {
                        const glass = compGroup.querySelector('.bulb-glass');
                        if(!glass || !glass.classList.contains('active')) {
                            allLit = false;
                        }
                    }
                });

                if(allLit) {
                    resultDiv.innerHTML = '<span class="text-success">ğŸ‰ æ­å–œï¼ç”µè·¯è¿é€šæ­£ç¡®ï¼Œç¯æ³¡å·²å…¨éƒ¨ç‚¹äº®ï¼</span>';
                } else {
                    resultDiv.innerHTML = '<span class="text-danger">ä»»åŠ¡å¤±è´¥ï¼šéƒ¨åˆ†ç¯æ³¡æœªèƒ½å‘å…‰ï¼Œè¯·æ£€æŸ¥æ”¯è·¯è¿çº¿ã€‚</span>';
                }
            } else {
                resultDiv.innerHTML = '<span class="text-success">ğŸ‰ æ­å–œï¼ä»»åŠ¡éªŒè¯é€šè¿‡ï¼ç”µè·¯æ— å¼‚å¸¸ã€‚</span>';
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            initPractices();

            document.getElementById('scene-select').addEventListener('change', (e) => {
                const val = e.target.value;
                const practicePanel = document.getElementById('practice-panel');
                
                document.getElementById('practice-edit-mode').classList.add('d-none');
                document.getElementById('practice-view-mode').classList.remove('d-none');

                if(val === 'practice') {
                    practicePanel.classList.remove('d-none');
                    initPractices(); 
                    loadSelectedPractice(); 
                } else {
                    practicePanel.classList.add('d-none');
                    resetCanvas(true);
                    setStatus('idle', 'ç­‰å¾…æ“ä½œï¼šå¯è‡ªç”±æ­å»ºç”µè·¯ã€‚');
                }
            });

            document.getElementById('mode-select').addEventListener('change', (e) => {
                const faultPanel = document.getElementById('fault-panel');
                if(e.target.value === 'fault') {
                    faultPanel.classList.remove('d-none');
                } else {
                    faultPanel.classList.add('d-none');
                    document.getElementById('fault-type').value = 'none';
                }
                resetSimulation();
            });

            document.getElementById('btn-trigger-fault').addEventListener('click', () => {
                if(!isSimulating) toggleSimulation();
                else updateSimulation();
            });

            canvasContainer.addEventListener('wheel', (e) => {
                if(isSimulating) return;
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const rect = canvasContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldX = (mouseX - canvasOffset.x) / canvasScale;
                const worldY = (mouseY - canvasOffset.y) / canvasScale;
                canvasScale = Math.max(0.3, Math.min(3, canvasScale * delta));
                canvasOffset.x = mouseX - worldX * canvasScale;
                canvasOffset.y = mouseY - worldY * canvasScale;
                updateCanvasTransform();
            }, {passive: false});

            canvasContainer.addEventListener('mousedown', (e) => {
                if(isSimulating) return;
                if(e.target === canvasContainer || e.target === canvas || e.target === canvasWrapper) {
                    if(e.button === 1 || (e.button === 0 && spaceKey)) {
                        e.preventDefault();
                        isDraggingCanvas = true;
                        canvasDragStart = { x: e.clientX, y: e.clientY };
                        canvasDragStartOffset = { ...canvasOffset };
                    }
                }
            });

            document.addEventListener('mousemove', (e) => {
                if(isDraggingCanvas) {
                    e.preventDefault();
                    canvasOffset.x = canvasDragStartOffset.x + (e.clientX - canvasDragStart.x);
                    canvasOffset.y = canvasDragStartOffset.y + (e.clientY - canvasDragStart.y);
                    updateCanvasTransform();
                }
            });

            document.addEventListener('mouseup', (e) => {
                if(e.button === 1 || e.button === 0) isDraggingCanvas = false;
            });

            let spaceKey = false;
            document.addEventListener('keydown', (e) => {
                if(e.code === 'Space') {
                    spaceKey = true;
                    canvasContainer.style.cursor = 'grab';
                }
            });
            document.addEventListener('keyup', (e) => {
                if(e.code === 'Space') {
                    spaceKey = false;
                    canvasContainer.style.cursor = '';
                    isDraggingCanvas = false;
                }
            });

            let touchStartDistance = 0, touchStartScale = 1, touchStartOffset = { x: 0, y: 0 }, lastTouchCenter = { x: 0, y: 0 };

            canvasContainer.addEventListener('touchstart', (e) => {
                if(isSimulating) return;
                if(e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0], touch2 = e.touches[1];
                    touchStartDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                    touchStartScale = canvasScale;
                    touchStartOffset = { ...canvasOffset };
                    lastTouchCenter = { x: (touch1.clientX + touch2.clientX) / 2, y: (touch1.clientY + touch2.clientY) / 2 };
                } else if(e.touches.length === 1 && !draggingComp && !tempWire) {
                    const rect = canvasContainer.getBoundingClientRect();
                    const touch = e.touches[0];
                    if(touch.clientX - rect.left < 50 && touch.clientY - rect.top < 50) {
                        isDraggingCanvas = true;
                        canvasDragStart = { x: touch.clientX, y: touch.clientY };
                        canvasDragStartOffset = { ...canvasOffset };
                    }
                }
            }, {passive: false});

            canvasContainer.addEventListener('touchmove', (e) => {
                if(e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0], touch2 = e.touches[1];
                    const distance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                    const scale = touchStartScale * (distance / touchStartDistance);
                    canvasScale = Math.max(0.3, Math.min(3, scale));
                    const center = { x: (touch1.clientX + touch2.clientX) / 2, y: (touch1.clientY + touch2.clientY) / 2 };
                    const rect = canvasContainer.getBoundingClientRect();
                    const worldX = (lastTouchCenter.x - rect.left - touchStartOffset.x) / touchStartScale;
                    const worldY = (lastTouchCenter.y - rect.top - touchStartOffset.y) / touchStartScale;
                    canvasOffset.x = center.x - rect.left - worldX * canvasScale;
                    canvasOffset.y = center.y - rect.top - worldY * canvasScale;
                    updateCanvasTransform();
                } else if(isDraggingCanvas && e.touches.length === 1) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    canvasOffset.x = canvasDragStartOffset.x + (touch.clientX - canvasDragStart.x);
                    canvasOffset.y = canvasDragStartOffset.y + (touch.clientY - canvasDragStart.y);
                    updateCanvasTransform();
                }
            }, {passive: false});

            canvasContainer.addEventListener('touchend', () => isDraggingCanvas = false);

            canvas.addEventListener('touchstart', handleDragStart, {passive: false});
            document.addEventListener('touchmove', handleDragMove, {passive: false});
            document.addEventListener('touchend', handleDragEnd);
            canvas.addEventListener('mousedown', handleDragStart);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);

            initPaletteDrag();
            updateCanvasTransform();
        });

        function showGuide() { new bootstrap.Modal(document.getElementById('guideModal')).show(); }

        function initPaletteDrag() {
            const paletteItems = document.querySelectorAll('.palette-item');
            paletteItems.forEach(item => {
                let holdTimer = null, isHolding = false;
                const startPaletteDrag = (pt, type) => {
                    if(isSimulating) return alert('è¯·å…ˆåœæ­¢å®éªŒå†ä¿®æ”¹ç”µè·¯');
                    const def = CompDefs[type];
                    const world = screenToWorld(pt.x, pt.y);
                    
                    let pinOffsetX = def.pins[0].x;
                    let pinOffsetY = def.pins[0].y;
                    const comp = {
                        id: 'comp_' + (++compCounter),
                        type: type,
                        x: Math.round((world.x - def.width / 2 + pinOffsetX) / gridSize) * gridSize - pinOffsetX,
                        y: Math.round((world.y - def.height / 2 + pinOffsetY) / gridSize) * gridSize - pinOffsetY,
                        def: def,
                        isClosed: false
                    };
                    components.push(comp);
                    draggingComp = comp;
                    dragOffset = { x: def.width / 2, y: def.height / 2 };
                    trashCan.classList.add('visible');
                    renderComponents();
                };

                item.addEventListener('touchstart', (e) => {
                    if(isSimulating) return;
                    const pt = getEventPoint(e);
                    isHolding = false;
                    holdTimer = setTimeout(() => {
                        isHolding = true;
                        startPaletteDrag(pt, item.getAttribute('data-type'));
                    }, 200); 
                }, {passive: true});

                item.addEventListener('touchmove', (e) => {
                    if (!isHolding && holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
                    if (isHolding) { e.preventDefault(); handleDragMove(e); }
                }, {passive: false});

                const cancelTouch = (e) => {
                    if (holdTimer) clearTimeout(holdTimer);
                    if (isHolding) { handleDragEnd(e); isHolding = false; }
                };
                item.addEventListener('touchend', cancelTouch);
                item.addEventListener('touchcancel', cancelTouch);

                item.addEventListener('mousedown', (e) => {
                    if(isSimulating) return alert('è¯·å…ˆåœæ­¢å®éªŒå†ä¿®æ”¹ç”µè·¯');
                    e.preventDefault();
                    startPaletteDrag(getEventPoint(e), item.getAttribute('data-type'));
                });
            });
        }

        function renderComponents() {
            layerComps.innerHTML = '';
            components.forEach(comp => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'component-group');
                g.setAttribute('transform', `translate(${comp.x}, ${comp.y})`);
                g.setAttribute('data-id', comp.id);
                
                let svgContent = comp.def.svg;
                if(comp.type === 'switch' && comp.isClosed) {
                    svgContent = svgContent.replace('y2="10"', 'y2="20"');
                }
                g.innerHTML = svgContent;

                if(comp.type === 'switch') {
                    g.addEventListener('dblclick', (e) => toggleSwitch(comp.id, e));
                    let touchStartTime = 0;
                    g.addEventListener('touchstart', () => touchStartTime = Date.now());
                    g.addEventListener('touchend', (e) => {
                        if(Date.now() - touchStartTime < 200 && !draggingComp) toggleSwitch(comp.id, e);
                    });
                }

                comp.def.pins.forEach(pin => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    const pinId = `${comp.id}_${pin.id}`;
                    circle.setAttribute('class', `terminal ${pin.type === 'negative' ? 'negative' : ''}`);
                    circle.setAttribute('cx', pin.x);
                    circle.setAttribute('cy', pin.y);
                    circle.setAttribute('r', 5);
                    circle.setAttribute('data-pinid', pinId);
                    circle.setAttribute('data-compid', comp.id);
                    g.appendChild(circle);
                });
                
                layerComps.appendChild(g);
            });
        }

        function toggleSwitch(id, e) {
            if(e) e.stopPropagation();
            const comp = components.find(c => c.id === id);
            if(comp) {
                comp.isClosed = !comp.isClosed;
                renderComponents();
                if(isSimulating) updateSimulation();
            }
        }

        function getPinCoords(pinId) {
            const lastIndex = pinId.lastIndexOf('_');
            const actualCompId = pinId.substring(0, lastIndex);
            const actualPinId = pinId.substring(lastIndex + 1);
            const c = components.find(x => x.id === actualCompId);
            if(!c) return {x:0, y:0};
            const p = c.def.pins.find(x => x.id === actualPinId);
            return { x: Math.round((c.x + p.x) / gridSize) * gridSize, y: Math.round((c.y + p.y) / gridSize) * gridSize };
        }

        function getPinDir(pinId) {
            const cId = pinId.substring(0, pinId.lastIndexOf('_'));
            const pId = pinId.substring(pinId.lastIndexOf('_') + 1);
            const comp = components.find(c => c.id === cId);
            if(!comp) return {x: 1, y: 0};
            const pin = comp.def.pins.find(p => p.id === pId);
            if(pin && pin.dir) return pin.dir;
            if(pin && pin.x < comp.def.width / 2) return {x: -1, y: 0};
            return {x: 1, y: 0};
        }

        function findAStarPath(start, end) {
            const gridStart = {x: Math.round(start.x/gridSize), y: Math.round(start.y/gridSize)};
            const gridEnd = {x: Math.round(end.x/gridSize), y: Math.round(end.y/gridSize)};

            if(gridStart.x === gridEnd.x && gridStart.y === gridEnd.y) return [start];

            let minX = Math.min(gridStart.x, gridEnd.x) - 10;
            let maxX = Math.max(gridStart.x, gridEnd.x) + 10;
            let minY = Math.min(gridStart.y, gridEnd.y) - 10;
            let maxY = Math.max(gridStart.y, gridEnd.y) + 10;

            components.forEach(c => {
                let gx = Math.floor(c.x / gridSize);
                let gy = Math.floor(c.y / gridSize);
                let gw = Math.ceil(c.def.width / gridSize);
                let gh = Math.ceil(c.def.height / gridSize);
                minX = Math.min(minX, gx - 2);
                maxX = Math.max(maxX, gx + gw + 2);
                minY = Math.min(minY, gy - 2);
                maxY = Math.max(maxY, gy + gh + 2);
            });

            const isObstacle = (x, y) => {
                return components.some(c => {
                    let cx = c.x / gridSize;
                    let cy = c.y / gridSize;
                    let cw = c.def.width / gridSize;
                    let ch = c.def.height / gridSize;
                    return x > cx && x < cx + cw && y > cy && y < cy + ch;
                });
            };

            let openSet = [gridStart];
            let cameFrom = new Map();
            let gScore = new Map();
            let fScore = new Map();
            
            const hash = (p) => `${p.x},${p.y}`;
            gScore.set(hash(gridStart), 0);
            fScore.set(hash(gridStart), Math.abs(gridStart.x - gridEnd.x) + Math.abs(gridStart.y - gridEnd.y));

            const dirs = [{x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0}];
            let iter = 0;

            while(openSet.length > 0 && iter < 3000) {
                iter++;
                let currIdx = 0;
                let minF = fScore.get(hash(openSet[0]));
                for(let i=1; i<openSet.length; i++) {
                    let f = fScore.get(hash(openSet[i]));
                    if(f < minF) { minF = f; currIdx = i; }
                }

                let current = openSet.splice(currIdx, 1)[0];
                let currentHash = hash(current);

                if (current.x === gridEnd.x && current.y === gridEnd.y) {
                    let path = [current];
                    while(cameFrom.has(hash(path[0]))) {
                        path.unshift(cameFrom.get(hash(path[0])));
                    }
                    let simplifiedPath = [path[0]];
                    let lastDir = null;
                    for(let i=1; i<path.length; i++){
                        let dx = path[i].x - path[i-1].x;
                        let dy = path[i].y - path[i-1].y;
                        if(lastDir && (lastDir.x !== dx || lastDir.y !== dy)) {
                            simplifiedPath.push(path[i-1]);
                        }
                        lastDir = {x: dx, y: dy};
                    }
                    simplifiedPath.push(path[path.length-1]);
                    return simplifiedPath.map(p => ({x: p.x * gridSize, y: p.y * gridSize}));
                }

                for(let dir of dirs) {
                    let neighbor = {x: current.x + dir.x, y: current.y + dir.y};
                    if(neighbor.x < minX || neighbor.x > maxX || neighbor.y < minY || neighbor.y > maxY) continue;

                    let moveCost = isObstacle(neighbor.x, neighbor.y) ? 100 : 1;
                    let turnPenalty = 0;
                    if (cameFrom.has(currentHash)) {
                        let prev = cameFrom.get(currentHash);
                        let prevDir = {x: current.x - prev.x, y: current.y - prev.y};
                        if (prevDir.x !== dir.x || prevDir.y !== dir.y) turnPenalty = 5; 
                    }

                    let t_gScore = gScore.get(currentHash) + moveCost + turnPenalty;
                    let neighborHash = hash(neighbor);

                    if (!gScore.has(neighborHash) || t_gScore < gScore.get(neighborHash)) {
                        cameFrom.set(neighborHash, current);
                        gScore.set(neighborHash, t_gScore);
                        fScore.set(neighborHash, t_gScore + Math.abs(neighbor.x - gridEnd.x) + Math.abs(neighbor.y - gridEnd.y));
                        if (!openSet.some(p => p.x === neighbor.x && p.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return null;
        }

        function getPathData(p1Id, c1, p2Id, c2) {
            let dir1 = getPinDir(p1Id);
            let dir2 = p2Id ? getPinDir(p2Id) : null;

            let ext1 = {x: c1.x + dir1.x * gridSize, y: c1.y + dir1.y * gridSize};
            let ext2 = dir2 ? {x: c2.x + dir2.x * gridSize, y: c2.y + dir2.y * gridSize} : {x: Math.round(c2.x/gridSize)*gridSize, y: Math.round(c2.y/gridSize)*gridSize};

            let path = findAStarPath(ext1, ext2);
            if (!path) {
                let midX = Math.round((ext1.x + ext2.x) / 2 / gridSize) * gridSize;
                path = [ext1, {x: midX, y: ext1.y}, {x: midX, y: ext2.y}, ext2];
            }
            
            path.unshift(c1);
            if(dir2) path.push(c2); else path.push({x: c2.x, y: c2.y}); 

            let d = `M ${path[0].x} ${path[0].y}`;
            for(let i=1; i<path.length; i++) {
                d += ` L ${path[i].x} ${path[i].y}`;
            }
            return d;
        }

        function renderWires() {
            layerWires.innerHTML = '';
            wires.forEach(wire => {
                const c1 = getPinCoords(wire.p1);
                const c2 = getPinCoords(wire.p2);
                
                const pathData = getPathData(wire.p1, c1, wire.p2, c2);

                const wireGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                const clickArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                clickArea.setAttribute('d', pathData);
                clickArea.setAttribute('class', 'wire-click-area');
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('class', 'wire');
                
                const removeWire = (e) => {
                    e.stopPropagation();
                    if(isSimulating) return;
                    wires = wires.filter(w => w.id !== wire.id);
                    renderWires();
                };
                clickArea.addEventListener('click', removeWire);
                clickArea.addEventListener('touchstart', removeWire);
                path.addEventListener('click', removeWire);
                path.addEventListener('touchstart', removeWire);
                
                wireGroup.appendChild(clickArea);
                wireGroup.appendChild(path);
                layerWires.appendChild(wireGroup);
            });

            if (tempWire) {
                const pathData = getPathData(tempWire.p1, {x: tempWire.startX, y: tempWire.startY}, tempWire.snapPin, {x: tempWire.endX, y: tempWire.endY});
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('class', 'wire');
                path.style.strokeDasharray = '5,5';
                path.style.pointerEvents = 'none';
                path.style.opacity = '0.7';
                layerWires.appendChild(path);
            }
        }

        function getEventPoint(e) {
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        function screenToWorld(screenX, screenY) {
            const rect = canvasContainer.getBoundingClientRect();
            return {
                x: (screenX - rect.left - canvasOffset.x) / canvasScale,
                y: (screenY - rect.top - canvasOffset.y) / canvasScale
            };
        }

        function handleDragStart(e) {
            if(isSimulating) return;

            if (e.target.classList && e.target.classList.contains('terminal')) {
                e.stopPropagation(); 
                const pinId = e.target.getAttribute('data-pinid');
                const startCoords = getPinCoords(pinId);
                
                tempWire = {
                    p1: pinId, startX: startCoords.x, startY: startCoords.y,
                    endX: startCoords.x, endY: startCoords.y, snapPin: null
                };

                allPinsCache = [];
                const sourceCompId = pinId.substring(0, pinId.lastIndexOf('_'));
                components.forEach(c => {
                    if(c.id === sourceCompId) return;
                    c.def.pins.forEach(p => {
                        const pid = `${c.id}_${p.id}`;
                        allPinsCache.push({
                            id: pid, coords: getPinCoords(pid),
                            element: document.querySelector(`[data-pinid="${pid}"]`)
                        });
                    });
                });
                return;
            }

            const target = e.target.closest ? e.target.closest('.component-group') : null;
            if (target && !e.target.classList.contains('terminal')) {
                const id = target.getAttribute('data-id');
                draggingComp = components.find(c => c.id === id);
                if (draggingComp) {
                    const pt = getEventPoint(e);
                    const world = screenToWorld(pt.x, pt.y);
                    dragOffset.x = world.x - draggingComp.x;
                    dragOffset.y = world.y - draggingComp.y;
                    trashCan.classList.add('visible'); 
                }
            }
        }

        function handleDragMove(e) {
            if (!tempWire && !draggingComp) return;
            e.preventDefault();
            if (tempWire) {
                const pt = getEventPoint(e);
                const world = screenToWorld(pt.x, pt.y);
                let minDist = 30 / canvasScale;
                let closestPin = null;

                allPinsCache.forEach(p => {
                    if(p.element) p.element.classList.remove('active');
                    let dx = world.x - p.coords.x;
                    let dy = world.y - p.coords.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < minDist) { minDist = dist; closestPin = p; }
                });

                if (closestPin) {
                    tempWire.endX = closestPin.coords.x; tempWire.endY = closestPin.coords.y;
                    tempWire.snapPin = closestPin.id;
                    if(closestPin.element) closestPin.element.classList.add('active');
                } else {
                    tempWire.endX = world.x; tempWire.endY = world.y;
                    tempWire.snapPin = null;
                }
                renderWires();
                return;
            }

            if (draggingComp) {
                const pt = getEventPoint(e);
                const world = screenToWorld(pt.x, pt.y);
                const trashRect = trashCan.getBoundingClientRect();
                if (pt.x > trashRect.left && pt.x < trashRect.right && pt.y > trashRect.top && pt.y < trashRect.bottom) {
                    trashCan.classList.add('active'); isHoveringTrash = true;
                } else {
                    trashCan.classList.remove('active'); isHoveringTrash = false;
                }

                let pinOffsetX = draggingComp.def.pins[0].x;
                let pinOffsetY = draggingComp.def.pins[0].y;
                let rawX = world.x - dragOffset.x;
                let rawY = world.y - dragOffset.y;
                let snapX = Math.round((rawX + pinOffsetX) / gridSize) * gridSize - pinOffsetX;
                let snapY = Math.round((rawY + pinOffsetY) / gridSize) * gridSize - pinOffsetY;
                
                draggingComp.x = snapX; draggingComp.y = snapY;
                const compGroup = document.querySelector(`g[data-id="${draggingComp.id}"]`);
                if (compGroup) compGroup.setAttribute('transform', `translate(${draggingComp.x}, ${draggingComp.y})`);
                renderWires();
            }
        }

        function handleDragEnd(e) {
            if (tempWire) {
                allPinsCache.forEach(p => { if(p.element) p.element.classList.remove('active'); });
                if (tempWire.snapPin) {
                    const fromComp = tempWire.p1.substring(0, tempWire.p1.lastIndexOf('_'));
                    const toComp = tempWire.snapPin.substring(0, tempWire.snapPin.lastIndexOf('_'));
                    const sameComp = fromComp === toComp;
                    const exist = wires.find(w => (w.p1 === tempWire.p1 && w.p2 === tempWire.snapPin) || (w.p2 === tempWire.p1 && w.p1 === tempWire.snapPin));
                    if(!exist && !sameComp) wires.push({ id: 'w_'+Date.now(), p1: tempWire.p1, p2: tempWire.snapPin });
                }
                tempWire = null; allPinsCache = [];
                renderWires();
                return;
            }

            if (draggingComp) {
                if (isHoveringTrash) {
                    components = components.filter(c => c.id !== draggingComp.id);
                    wires = wires.filter(w => !w.p1.startsWith(draggingComp.id) && !w.p2.startsWith(draggingComp.id));
                }
                draggingComp = null; isHoveringTrash = false;
                trashCan.classList.remove('visible', 'active');
                renderComponents(); renderWires();
            }
        }

        function resetCanvas(silent = false) {
            if(silent || confirm("ç¡®å®šæ¸…ç©ºç”»å¸ƒå¹¶é‡ç½®å—ï¼Ÿ")) {
                components = []; wires = []; compCounter = 0;
                resetSimulation(); renderComponents(); renderWires();
                if(document.getElementById('practice-result')) {
                    document.getElementById('practice-result').innerText = '';
                }
            }
        }

        function resetSimulation() {
            isSimulating = false;
            conductingWireIds = new Set();
            document.getElementById('btn-simulate').innerText = "å¯åŠ¨å®éªŒ";
            document.getElementById('btn-simulate').classList.replace('btn-warning', 'btn-primary');
            setStatus('idle', document.getElementById('scene-select').value === 'practice' ? 'ç›®æ ‡ä»»åŠ¡æ¨¡å¼ï¼šè¯·æ ¹æ®æç¤ºè¿æ¥ç”µè·¯ã€‚' : 'ç­‰å¾…æ“ä½œ (æœªè¿æ¥ç”µæº)');
            document.querySelectorAll('.bulb-glass, .bulb-cross').forEach(el => el.classList.remove('active'));
            renderWires();
        }

        function toggleSimulation() {
            if(isSimulating) {
                resetSimulation();
            } else {
                isSimulating = true;
                renderComponents();
                document.getElementById('btn-simulate').innerText = "åœæ­¢å®éªŒ";
                document.getElementById('btn-simulate').classList.replace('btn-primary', 'btn-warning');
                updateSimulation();
            }
        }

        function setStatus(type, text) {
            statusDisplay.className = `status-box status-${type}`;
            statusDisplay.innerText = text;
        }

        function buildGraph(opts = {}) {
            let graph = {};
            const addEdge = (u, v, res, comp = null) => {
                if(!graph[u]) graph[u] = []; if(!graph[v]) graph[v] = [];
                graph[u].push({to: v, res: res, comp: comp}); graph[v].push({to: u, res: res, comp: comp});
            };

            components.forEach(c => {
                if(c.type === 'battery') return;
                const p1 = `${c.id}_p1`, p2 = `${c.id}_p2`;
                let res = c.def.res;
                if(c.type === 'switch') res = (opts.forceSwitchesClosed || c.isClosed) ? 0 : 999999;
                if(opts.applianceShort && (c.type === 'bulb' || c.type === 'resistor')) res = 0;
                addEdge(p1, p2, res, c);
            });

            let effectiveWires = opts.breakWireIndex !== undefined && opts.breakWireIndex >= 0 && opts.breakWireIndex < wires.length ? 
                wires.filter((_, i) => i !== opts.breakWireIndex) : wires;
            effectiveWires.forEach(w => addEdge(w.p1, w.p2, 0, null));

            if(opts.powerShort) {
                const battery = components.find(c => c.type === 'battery');
                if(battery) addEdge(`${battery.id}_p1`, `${battery.id}_p2`, 0, null);
            }
            return { graph, addEdge };
        }

        function dijkstra(graph, startPin, endPin) {
            let dist = {}, prev = {};
            for(let node in graph) dist[node] = Infinity;
            dist[startPin] = 0;
            let pq = [startPin], visited = {};
            while(pq.length > 0) {
                pq.sort((a,b) => dist[a] - dist[b]);
                let u = pq.shift();
                if(visited[u]) continue;
                visited[u] = true;
                if(!graph[u]) continue;
                for(let edge of graph[u]) {
                    let alt = dist[u] + edge.res;
                    if(alt < dist[edge.to]) {
                        dist[edge.to] = alt;
                        prev[edge.to] = { from: u, comp: edge.comp };
                        pq.push(edge.to);
                    }
                }
            }
            return { dist, prev };
        }

        // ================= æ ¸å¿ƒä¿®å¤é€»è¾‘ï¼šæ‹“æ‰‘å»æ­»èƒ¡åŒç®—æ³• =================
        function findAllConductingComps(graph, startPin, endPin) {
            let workingGraph = {};
            let degrees = {};
            let validEdges = [];

            // 1. åˆå§‹åŒ–åº¦æ•°ï¼Œå¹¶å‰¥ç¦»æ–­å¼€çš„å…ƒä»¶ï¼ˆç”µé˜»æ— ç©·å¤§ï¼‰
            for(let node in graph) degrees[node] = 0;

            for (let u in graph) {
                workingGraph[u] = [];
                for (let edge of graph[u]) {
                    if (edge.res < 999999) { // åªçœ‹é€šè·¯
                        workingGraph[u].push({...edge});
                        degrees[u]++;
                        if (u < edge.to) { // é¿å…åŒå‘è¾¹é‡å¤è®¡ç®—
                            validEdges.push({u: u, v: edge.to, comp: edge.comp});
                        }
                    }
                }
            }

            // 2. æ‰¾å‡ºæ‰€æœ‰åº¦ä¸º1çš„èŠ‚ç‚¹ï¼ˆæ­»èƒ¡åŒå°½å¤´ï¼‰ï¼Œæ’é™¤ç”µæºèŠ‚ç‚¹
            let queue = [];
            for (let node in degrees) {
                if (degrees[node] === 1 && node !== startPin && node !== endPin) {
                    queue.push(node);
                }
            }

            let removedNodes = new Set();
            
            // 3. å‰¥æ´‹è‘±å¼å‰ªæï¼šä¸æ–­å»æ‰æ­»èƒ¡åŒï¼Œç›´åˆ°åªå‰©ä¸‹å®Œæ•´å›è·¯
            while (queue.length > 0) {
                let u = queue.shift();
                if (removedNodes.has(u)) continue;
                removedNodes.add(u);
                degrees[u] = 0;

                // æ‰¾åˆ°ä¸å®ƒç›¸è¿çš„é‚£ä¸ªèŠ‚ç‚¹ï¼Œåº¦æ•°å‡1
                for (let edge of workingGraph[u]) {
                    let v = edge.to;
                    if (!removedNodes.has(v)) {
                        degrees[v]--;
                        // å¦‚æœé‚£ä¸ªèŠ‚ç‚¹ä¹Ÿå˜æˆäº†æ–°çš„æ­»èƒ¡åŒå°½å¤´ï¼ŒåŠ è¿›é˜Ÿåˆ—ç»§ç»­å‰ª
                        if (degrees[v] === 1 && v !== startPin && v !== endPin) {
                            queue.push(v);
                        }
                    }
                }
            }

            // 4. åœ¨å‰ªè£å¹²å‡€çš„â€œéª¨æ¶â€ä¸Šï¼Œä»ç”µæºæ­£æå‡ºå‘è¿›è¡Œéå†ï¼Œèƒ½æ‘¸åˆ°çš„æ‰æ˜¯é€šç”µçš„
            let reachable = new Set();
            let bfsQueue = [startPin];
            reachable.add(startPin);

            while (bfsQueue.length > 0) {
                let u = bfsQueue.shift();
                if(removedNodes.has(u)) continue; 

                for (let edge of workingGraph[u]) {
                    let v = edge.to;
                    if (!removedNodes.has(v) && !reachable.has(v)) {
                        reachable.add(v);
                        bfsQueue.push(v);
                    }
                }
            }

            // 5. ç»„è£…ç»“æœ
            let conductingComps = new Set();
            let conductingEdges = new Set();
            let hasLoad = false;

            for (let e of validEdges) {
                // å¦‚æœè¿™æ¡è¾¹ä¸¤ç«¯éƒ½æ²¡è¢«å‰ªæ‰ï¼Œä¸”éƒ½èƒ½è¢«ç”µæºæ‘¸åˆ°
                if (!removedNodes.has(e.u) && !removedNodes.has(e.v) && reachable.has(e.u) && reachable.has(e.v)) {
                    conductingEdges.add(e.u + '|' + e.v);
                    conductingEdges.add(e.v + '|' + e.u);
                    if (e.comp) {
                        conductingComps.add(e.comp);
                        if (e.comp.type === 'bulb' || e.comp.type === 'resistor') {
                            hasLoad = true;
                        }
                    }
                }
            }

            // ç®—å‡ºæ€»ç”µé˜»ä¾›å…¶ä»–é€»è¾‘ä½¿ç”¨
            let { dist } = dijkstra(graph, startPin, endPin);

            return { comps: conductingComps, wireEdges: conductingEdges, totalRes: dist[endPin], hasLoad };
        }
        // =================================================================

        function getZeroResCluster(graph, startPin, ignoreCompId) {
            let cluster = new Set();
            let queue = [startPin];
            cluster.add(startPin);
            while(queue.length > 0) {
                let u = queue.shift();
                if(!graph[u]) continue;
                for(let edge of graph[u]) {
                    if(edge.comp && edge.comp.id === ignoreCompId) continue; 
                    if(edge.res === 0 && !cluster.has(edge.to)) {
                        cluster.add(edge.to);
                        queue.push(edge.to);
                    }
                }
            }
            return cluster;
        }

        function checkRangeError(battery, totalRes, dist) {
            if(!battery || totalRes <= 0 || totalRes >= 999999) return [];
            const voltage = 1.5, current = voltage / totalRes;
            let faults = [];
            components.forEach(c => {
                if(c.type === 'ammeter') {
                    if(current > 0.6) faults.push(`ç”µæµè¡¨(${c.id})é‡ç¨‹è¿‡å°(ç”µæµ${current.toFixed(2)}A > 0.6Aé‡ç¨‹)ï¼Œå¯èƒ½çƒ§æ¯`);
                    else if(current < 0.02) faults.push(`ç”µæµè¡¨(${c.id})åè½¬è¿‡å°(ç”µæµ${current.toFixed(3)}A)ï¼Œåº”æ¢å°é‡ç¨‹`);
                }
                if(c.type === 'voltmeter') {
                    let cp1 = `${c.id}_p1`, cp2 = `${c.id}_p2`;
                    let d1 = dist[cp1] !== undefined ? dist[cp1] : Infinity;
                    let d2 = dist[cp2] !== undefined ? dist[cp2] : Infinity;
                    let measuredV = 0;
                    if(d1 !== Infinity && d2 !== Infinity) {
                        measuredV = current * Math.abs(d1 - d2);
                    }
                    if(measuredV > 3) faults.push(`ç”µå‹è¡¨(${c.id})é‡ç¨‹è¿‡å°(æµ‹å¾—ç”µå‹${measuredV.toFixed(2)}V > 3Vé‡ç¨‹)ï¼Œå¯èƒ½çƒ§æ¯`);
                    else if(measuredV > 0 && measuredV < 0.1) faults.push(`ç”µå‹è¡¨(${c.id})åè½¬è¿‡å°(æµ‹å¾—ç”µå‹${measuredV.toFixed(2)}V)ï¼Œåº”æ¢å°é‡ç¨‹`);
                }
            });
            return faults;
        }

        function autoDetectFaults(battery) {
            let allFaults = [];
            const batP1 = `${battery.id}_p1`, batP2 = `${battery.id}_p2`;
            let { graph } = buildGraph({}), { dist } = dijkstra(graph, batP1, batP2);
            let totalRes = dist[batP2];

            if(totalRes === 0) {
                let allResult = findAllConductingComps(graph, batP1, batP2);
                allFaults.push(allResult.hasLoad ? 'âš ï¸ ç”¨ç”µå™¨è¢«çŸ­è·¯ï¼æœ‰å¯¼çº¿ç›´æ¥ç»•è¿‡äº†ç”¨ç”µå™¨ã€‚' : 'âš ï¸ ç”µæºçŸ­è·¯ï¼ç”µæ± æ­£è´Ÿæä¹‹é—´æ— ç”¨ç”µå™¨ï¼Œä¼šçƒ§æ¯ç”µæºã€‚');
            }

            if(totalRes >= 999999) {
                let openSwitches = components.filter(c => c.type === 'switch' && !c.isClosed);
                if(openSwitches.length > 0) allFaults.push('æ–­è·¯: å¼€å…³æœªé—­åˆã€‚');

                let { graph: closedGraph } = buildGraph({});
                components.forEach(c => {
                    if(c.type === 'switch' && !c.isClosed) {
                        const p1 = `${c.id}_p1`, p2 = `${c.id}_p2`;
                        if(!closedGraph[p1]) closedGraph[p1] = []; if(!closedGraph[p2]) closedGraph[p2] = [];
                        closedGraph[p1].push({to: p2, res: 0, comp: c}); closedGraph[p2].push({to: p1, res: 0, comp: c});
                    }
                });
                if(dijkstra(closedGraph, batP1, batP2).dist[batP2] >= 999999) allFaults.push('æ–­è·¯: å³ä½¿é—­åˆæ‰€æœ‰å¼€å…³ï¼Œç”µè·¯ä»ä¸è¿é€šï¼Œè¯·æ£€æŸ¥å¯¼çº¿ã€‚');
            }

            if(totalRes > 0 && totalRes < 999999) allFaults = allFaults.concat(checkRangeError(battery, totalRes, dist));

            components.forEach(c => {
                if(c.type === 'ammeter') {
                    const cp1 = `${c.id}_p1`, cp2 = `${c.id}_p2`;
                    let cluster1 = getZeroResCluster(graph, cp1, c.id);
                    let cluster2 = getZeroResCluster(graph, cp2, c.id);

                    if (!cluster1.has(cp2)) {
                        components.forEach(mc => {
                            if(mc.type === 'bulb' || mc.type === 'resistor') {
                                let mp1 = `${mc.id}_p1`, mp2 = `${mc.id}_p2`;
                                if ((cluster1.has(mp1) && cluster2.has(mp2)) || (cluster1.has(mp2) && cluster2.has(mp1))) {
                                    allFaults.push(`ç”µæµè¡¨(${c.id})å¹¶è”åœ¨äº†${mc.type === 'bulb' ? 'ç¯æ³¡' : 'å®šå€¼ç”µé˜»'}(${mc.id})ä¸¤ç«¯ï¼Œåº”ä¸²è”ä½¿ç”¨ã€‚`);
                                }
                            }
                        });
                    }
                }
                if(c.type === 'voltmeter') {
                    let { graph: fullGraph } = buildGraph({ forceSwitchesClosed: true });
                    let distWith = dijkstra(fullGraph, batP1, batP2).dist[batP2];
                    distWith = distWith !== undefined ? distWith : Infinity;
                    
                    let { graph: testGraph } = buildGraph({ forceSwitchesClosed: true });
                    
                    if (testGraph[`${c.id}_p1`]) {
                        testGraph[`${c.id}_p1`] = testGraph[`${c.id}_p1`].filter(e => e.comp !== c);
                    }
                    if (testGraph[`${c.id}_p2`]) {
                        testGraph[`${c.id}_p2`] = testGraph[`${c.id}_p2`].filter(e => e.comp !== c);
                    }
                    
                    let distWithout = dijkstra(testGraph, batP1, batP2).dist[batP2];
                    distWithout = distWithout !== undefined ? distWithout : Infinity;
                    
                    if(distWith < Infinity && distWithout >= 999999) {
                        allFaults.push(`ç”µå‹è¡¨(${c.id})ä¸²è”åœ¨äº†ç”µè·¯ä¸­ï¼Œåº”å¹¶è”ä½¿ç”¨ã€‚`);
                    }
                }
            });
            return allFaults;
        }

        function updateSimulation() {
            const faultSelect = document.getElementById('fault-type').value;
            const isFaultMode = document.getElementById('mode-select').value === 'fault';
            const battery = components.find(c => c.type === 'battery');
            if(!battery) return setStatus('error', 'æœªæ£€æµ‹åˆ°ç”µæºï¼Œç”µè·¯æ–­è·¯ã€‚');

            const batP1 = `${battery.id}_p1`, batP2 = `${battery.id}_p2`;
            
            let opts = {};
            if(isFaultMode && faultSelect !== 'none') {
                if(faultSelect === 'power_short') opts.powerShort = true;
                if(faultSelect === 'appliance_short') opts.applianceShort = true;
                if(faultSelect === 'wire_break' && wires.length > 0) opts.breakWireIndex = Math.floor(Math.random() * wires.length);
            }

            let { graph } = buildGraph(opts);
            if(!graph[batP1]) graph[batP1] = []; if(!graph[batP2]) graph[batP2] = [];
            let { dist } = dijkstra(graph, batP1, batP2);
            let totalRes = dist[batP2];

            document.querySelectorAll('.bulb-glass, .bulb-cross').forEach(el => el.classList.remove('active'));
            conductingWireIds = new Set();

            if(isFaultMode && faultSelect !== 'none') {
                if(faultSelect === 'range_error') {
                    let { graph: normalGraph } = buildGraph({}), { dist: normalDist } = dijkstra(normalGraph, batP1, batP2);
                    let normalRes = normalDist[batP2];
                    if(normalRes > 0 && normalRes < 999999) {
                        lightBulbsAll(normalGraph, batP1, batP2); conductingWireIds = findConductingWiresAll(normalGraph, batP1, batP2); renderWires();
                        let voltage = 1.5, current = voltage / normalRes, msgs = [];
                        components.forEach(c => {
                            if(c.type === 'ammeter') msgs.push(`ç”µæµè¡¨(${c.id}): ç”µæµ${current.toFixed(3)}Aï¼Œ${current > 0.6 ? 'è¶…é‡ç¨‹' : current < 0.02 ? 'åè½¬å¤ªå°' : 'æ­£å¸¸'}`);
                            if(c.type === 'voltmeter') {
                                let cp1 = `${c.id}_p1`, cp2 = `${c.id}_p2`;
                                let d1 = normalDist[cp1] !== undefined ? normalDist[cp1] : Infinity;
                                let d2 = normalDist[cp2] !== undefined ? normalDist[cp2] : Infinity;
                                let measuredV = (d1 !== Infinity && d2 !== Infinity) ? current * Math.abs(d1 - d2) : 0;
                                msgs.push(`ç”µå‹è¡¨(${c.id}): æµ‹å¾—ç”µå‹çº¦${measuredV.toFixed(1)}Vï¼Œè‹¥é‡ç¨‹3Våˆ™${measuredV > 3 ? 'è¶…é‡ç¨‹' : 'æ­£å¸¸'}`);
                            }
                        });
                        if(msgs.length === 0) return setStatus('error', 'âš ï¸ ç”µè·¯ä¸­æ²¡æœ‰ç”µè¡¨ï¼Œæ— æ³•æ¨¡æ‹Ÿé‡ç¨‹æ•…éšœã€‚');
                        return setStatus('error', 'âš ï¸ é‡ç¨‹åˆ†æ:\n' + msgs.join('\n'));
                    }
                    return setStatus('error', 'âš ï¸ ç”µè·¯æœªå¯¼é€šï¼Œæ— æ³•åˆ†æé‡ç¨‹ã€‚');
                }
                if(faultSelect === 'wire_break') {
                    if(totalRes >= 999999) { renderWires(); return setStatus('error', 'âš ï¸ æ•…éšœ: å¯¼çº¿æ–­è·¯ï¼ç”µè·¯ä¸­æœ‰ä¸€æ ¹å¯¼çº¿æ–­å¼€ï¼Œç”µè·¯ä¸é€šã€‚'); }
                    else {
                        lightBulbsAll(graph, batP1, batP2); conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires();
                        return setStatus('error', 'âš ï¸ æ•…éšœ: å¯¼çº¿æ–­è·¯ï¼æ–­å¼€çš„å¯¼çº¿æœªå½±å“ä¸»å›è·¯ï¼Œä½†éƒ¨åˆ†æ”¯è·¯å¯èƒ½å¤±æ•ˆã€‚');
                    }
                }
                if(totalRes >= 999999) { renderWires(); return setStatus('idle', 'çŠ¶æ€: æ–­è·¯ (å¼€å…³æœªé—­åˆæˆ–çº¿è·¯æœªè¿é€š)'); }
                else if(totalRes === 0) {
                    let allResult = findAllConductingComps(graph, batP1, batP2);
                    if(!allResult.hasLoad) { renderWires(); return setStatus('error', 'âš ï¸ è­¦å‘Š: ç”µæºçŸ­è·¯ï¼è¯·ç«‹å³æ–­å¼€å¼€å…³ã€‚'); }
                    else { conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires(); return setStatus('error', 'âš ï¸ ç”¨ç”µå™¨è¢«çŸ­è·¯ï¼æœ‰å¯¼çº¿ç›´æ¥ç»•è¿‡äº†ç”¨ç”µå™¨ã€‚ç¯æ³¡ä¸äº®ã€‚'); }
                } else {
                    lightBulbsAll(graph, batP1, batP2); conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires();
                    return setStatus('success', 'çŠ¶æ€: å¯¼é€šã€‚å®éªŒæ­£å¸¸è¿›è¡Œã€‚');
                }
            }

            if(isFaultMode && faultSelect === 'none') {
                let detectedFaults = autoDetectFaults(battery);
                if(detectedFaults.length > 0) {
                    if(totalRes > 0 && totalRes < 999999) { lightBulbsAll(graph, batP1, batP2); conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires(); }
                    return setStatus('error', 'ğŸ” è‡ªåŠ¨è¯†åˆ«:\n' + detectedFaults.join('\n'));
                }
            }

            if(totalRes >= 999999) { renderWires(); setStatus('idle', 'çŠ¶æ€: æ–­è·¯ (å¼€å…³æœªé—­åˆæˆ–çº¿è·¯æœªè¿é€š)'); }
            else if(totalRes === 0) {
                let allResult = findAllConductingComps(graph, batP1, batP2);
                if(!allResult.hasLoad) { renderWires(); setStatus('error', 'âš ï¸ è­¦å‘Š: ç”µæºçŸ­è·¯ï¼è¯·ç«‹å³æ–­å¼€å¼€å…³ã€‚'); }
                else { conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires(); setStatus('error', 'âš ï¸ ç”¨ç”µå™¨è¢«çŸ­è·¯ï¼æœ‰å¯¼çº¿ç›´æ¥ç»•è¿‡äº†ç”¨ç”µå™¨ã€‚'); }
            } else {
                lightBulbsAll(graph, batP1, batP2); conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires();
                setStatus('success', 'çŠ¶æ€: å¯¼é€šã€‚å®éªŒæ­£å¸¸è¿›è¡Œã€‚');
            }

            if(document.getElementById('scene-select').value === 'practice') {
                const resDiv = document.getElementById('practice-result');
                if (resDiv.innerHTML.includes('å¤±è´¥')) resDiv.innerHTML = '';
            }
        }

        function lightBulbsAll(graph, startPin, endPin) {
            let result = findAllConductingComps(graph, startPin, endPin);
            for(let comp of result.comps) {
                if(comp.type === 'bulb') {
                    const compGroup = document.querySelector(`g[data-id="${comp.id}"]`);
                    if(compGroup) {
                        compGroup.querySelector('.bulb-glass').classList.add('active');
                        let cross = compGroup.querySelector('.bulb-cross');
                        if(cross) cross.classList.add('active');
                    }
                }
            }
        }

        function findConductingWiresAll(graph, startPin, endPin) {
            let result = findAllConductingComps(graph, startPin, endPin);
            let ids = new Set();
            wires.forEach(w => {
                if(result.wireEdges.has(w.p1 + '|' + w.p2) || result.wireEdges.has(w.p2 + '|' + w.p1)) ids.add(w.id);
            });
            return ids;
        }
    </script>
</body>
</html>