<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>物理电路实验</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        :root {
            --grid-size: 20px;
            --primary-color: #0d6efd;
            --wire-color: #333;
            --canvas-bg: #f8f9fa;
        }
        body {
            overscroll-behavior-y: none;
            touch-action: pan-x pan-y;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            display: flex;
            flex-direction: column;
            height: 100dvh;
            margin: 0;
            background-color: #e9ecef;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        /* 顶部导航与控制区 */
        .header-area {
            background: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            z-index: 10;
            padding: 10px;
        }
        /* 元件库水平滚动区 */
        .component-palette {
            display: flex;
            overflow-x: auto;
            white-space: nowrap;
            padding: 10px;
            background: #fff;
            border-bottom: 1px solid #ddd;
            gap: 10px;
            -webkit-overflow-scrolling: touch;
        }
        .palette-item {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 70px;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
            touch-action: pan-x;
        }
        .palette-item:active { background-color: #e9ecef; }
        .palette-item svg { width: 40px; height: 40px; margin-bottom: 5px; pointer-events: none; }
        .palette-item span { font-size: 12px; color: #495057; pointer-events: none; }
        
        /* 核心画布区 */
        .canvas-container {
            flex: 1;
            position: relative;
            background-color: var(--canvas-bg);
            background-image:
                linear-gradient(to right, #ddd 1px, transparent 1px),
                linear-gradient(to bottom, #ddd 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            background-position: 0 0;
            overflow: hidden;
            touch-action: none;
        }
        .canvas-wrapper {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            transition: none;
        }
        #circuit-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* 垃圾桶区 */
        .trash-can {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            background-color: rgba(220, 53, 69, 0.15);
            color: #dc3545;
            border: 2px dashed #dc3545;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: all 0.2s ease;
            opacity: 0;
            pointer-events: none;
            transform: scale(0.8);
        }
        .trash-can.visible {
            opacity: 1;
            transform: scale(1);
        }
        .trash-can.active {
            transform: scale(1.2);
            background-color: #dc3545;
            color: #fff;
            border-style: solid;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }

        /* SVG 样式 */
        .wire { stroke: var(--wire-color); stroke-width: 3; fill: none; stroke-linejoin: round; cursor: pointer; transition: stroke 0.3s; }
        .wire:hover { stroke: #dc3545; }
        .wire-click-area { stroke: transparent; stroke-width: 20; fill: none; cursor: pointer; }
        
        .component-group { cursor: grab; }
        .component-group:active { cursor: grabbing; }
        .terminal { fill: #dc3545; stroke: #fff; stroke-width: 2; cursor: crosshair; transition: r 0.2s; }
        .terminal.negative { fill: #0dcaf0; }
        .terminal:hover, .terminal.active { r: 8; stroke: #ffc107; stroke-width: 3; }
        
        /* 灯泡发光效果 */
        .bulb-glass { fill: #fff; transition: all 0.3s ease; }
        .bulb-cross { stroke: #333; transition: all 0.3s ease; }
        .bulb-glass.active {
            fill: #fff9c4;
            filter: drop-shadow(0 0 8px #ffeb3b);
            stroke: #fbc02d;
        }
        .bulb-cross.active { stroke: #fbc02d; }

        /* 状态与控制栏 */
        .footer-area {
            background: #fff;
            padding: 10px;
            border-top: 1px solid #ddd;
            z-index: 10;
        }
        .status-box {
            font-size: 14px;
            font-weight: bold;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        .status-idle { background: #e9ecef; color: #495057; }
        .status-success { background: #d1e7dd; color: #0f5132; }
        .status-error { background: #f8d7da; color: #842029; }
    </style>
</head>
<body>

    <!-- 顶部控制区 -->
    <div class="header-area d-flex justify-content-between align-items-center">
        <h5 class="m-0 text-truncate" style="max-width: 20%;">物理电路实验</h5>
        <div class="d-flex gap-2">
            <select class="form-select form-select-sm" id="scene-select">
                <option value="class">课中演示</option>
                <option value="practice">课后练习</option>
            </select>
            <select class="form-select form-select-sm" id="mode-select">
                <option value="basic">基础搭建</option>
                <option value="fault">故障模拟</option>
            </select>
        </div>
    </div>

    <!-- 故障模拟专区 -->
    <div id="fault-panel" class="bg-light px-2 py-2 border-bottom d-none">
        <div class="d-flex align-items-center justify-content-between gap-2">
            <span style="font-size: 13px; white-space: nowrap;">植入故障:</span>
            <select class="form-select form-select-sm" id="fault-type">
                <option value="none">无故障 (自动识别)</option>
                <option value="power_short">电源短路</option>
                <option value="appliance_short">用电器短路</option>
                <option value="wire_break">导线断路</option>
                <option value="range_error">量程选错</option>
            </select>
            <button style="width: 80px;" class="btn btn-sm btn-outline-danger" id="btn-trigger-fault">触发</button>
        </div>
    </div>

    <!-- 物理原理图符号库 -->
    <div class="component-palette" id="palette">
        <div class="palette-item" data-type="battery">
            <svg viewBox="0 0 60 40">
                <path d="M 5 20 L 25 20 M 25 10 L 25 30 M 35 15 L 35 25 M 35 20 L 55 20" stroke="#333" stroke-width="2"/>
                <path d="M 35 15 L 35 25" stroke="#333" stroke-width="4"/>
                <text x="12" y="15" font-size="12">+</text>
                <text x="42" y="15" font-size="12">-</text>
            </svg>
            <span>电源</span>
        </div>
        <div class="palette-item" data-type="bulb">
            <svg viewBox="0 0 60 60">
                <circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/>
                <path d="M 19 19 L 41 41 M 19 41 L 41 19" stroke="#333" stroke-width="2"/>
                <path d="M 5 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>
            </svg>
            <span>灯泡</span>
        </div>
        <div class="palette-item" data-type="resistor">
            <svg viewBox="0 0 60 40">
                <rect x="15" y="15" width="30" height="10" fill="#fff" stroke="#333" stroke-width="2"/>
                <path d="M 5 20 L 15 20 M 45 20 L 55 20" stroke="#333" stroke-width="2"/>
                <text x="30" y="12" font-size="10" text-anchor="middle">10Ω</text>
            </svg>
            <span>定值电阻</span>
        </div>
        <div class="palette-item" data-type="switch">
            <svg viewBox="0 0 60 40">
                <path d="M 5 20 L 20 20 M 40 20 L 55 20" stroke="#333" stroke-width="2"/>
                <circle cx="20" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/>
                <circle cx="40" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/>
                <line x1="20" y1="20" x2="38" y2="10" stroke="#333" stroke-width="2"/>
            </svg>
            <span>开关</span>
        </div>
        <div class="palette-item" data-type="ammeter">
            <svg viewBox="0 0 60 60">
                <circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/>
                <text x="30" y="35" font-size="14" font-weight="bold" text-anchor="middle">A</text>
                <path d="M 5 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>
            </svg>
            <span>电流表</span>
        </div>
        <div class="palette-item" data-type="voltmeter">
            <svg viewBox="0 0 60 60">
                <circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/>
                <text x="30" y="35" font-size="14" font-weight="bold" text-anchor="middle">V</text>
                <path d="M 5 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>
            </svg>
            <span>电压表</span>
        </div>
    </div>

    <!-- 实验画布 -->
    <div class="canvas-container" id="canvas-container">
        <div class="canvas-wrapper" id="canvas-wrapper">
            <svg id="circuit-canvas">
                <!-- 导线层 -->
                <g id="layer-wires"></g>
                <!-- 元件层 -->
                <g id="layer-components"></g>
            </svg>
        </div>
        
        <!-- 删除垃圾桶 -->
        <div id="trash-can" class="trash-can">
            <svg viewBox="0 0 24 24" width="28" height="28" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
        </div>
    </div>

    <!-- 底部控制区 -->
    <div class="footer-area">
        <div id="status-display" class="status-box status-idle">等待操作 (未连接电源)</div>
        <div class="d-flex justify-content-between gap-2">
            <button class="btn btn-secondary flex-fill" onclick="showGuide()">操作指南</button>
            <button class="btn btn-danger flex-fill" onclick="resetCanvas()">重置画布</button>
            <button class="btn btn-primary flex-fill" id="btn-simulate" onclick="toggleSimulation()">启动实验</button>
        </div>
    </div>

    <!-- 3步操作指南 Modal -->
    <div class="modal fade" id="guideModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">简单三步操作指南</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                    <h6>第一步：添加与摆放</h6>
                    <p class="text-muted small"><strong>长按或拖拽</strong>顶部元件库中的元件，移动至画布松手。<br>拖入右下角<strong>垃圾桶</strong>可将其删除。</p>
                    <hr>
                    <h6>第二步：拖拽连线</h6>
                    <p class="text-muted small"><strong>按住</strong>元件两端的引脚节点，拖动进行连线。点击已连好的导线可将其删除。</p>
                    <hr>
                    <h6>第三步：启动与诊断</h6>
                    <p class="text-muted small">确保电路闭合后，点击“启动实验”，观察灯泡发光或底部状态栏的故障提示。</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary w-100" data-bs-dismiss="modal">我知道了</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        const canvas = document.getElementById('circuit-canvas');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvasContainer = document.getElementById('canvas-container');
        const layerWires = document.getElementById('layer-wires');
        const layerComps = document.getElementById('layer-components');
        const statusDisplay = document.getElementById('status-display');
        const trashCan = document.getElementById('trash-can');
        
        let components = [];
        let wires = [];
        let compCounter = 0;
        let isSimulating = false;
        let conductingWireIds = new Set();
        
        let draggingComp = null;
        let dragOffset = { x: 0, y: 0 };
        let isHoveringTrash = false;

        let tempWire = null; 
        let allPinsCache = [];
        
        let canvasScale = 1;
        let canvasOffset = { x: 0, y: 0 };
        let isDraggingCanvas = false;
        let canvasDragStart = { x: 0, y: 0 };
        let canvasDragStartOffset = { x: 0, y: 0 };
        
        const gridSize = 20;

        // 统一为标准物理原理图符号定义
        const CompDefs = {
            battery: {
                width: 60, height: 40, res: 0, type: 'source',
                svg: `<rect width="60" height="40" fill="transparent"/><path d="M 0 20 L 25 20 M 25 10 L 25 30 M 35 15 L 35 25 M 35 20 L 60 20" stroke="#333" stroke-width="2"/><path d="M 35 15 L 35 25" stroke="#333" stroke-width="4"/><text x="15" y="12" font-size="12">+</text><text x="40" y="12" font-size="12">-</text>`,
                pins: [{id: 'p1', x: 0, y: 20, type:'positive'}, {id: 'p2', x: 60, y: 20, type:'negative'}]
            },
            bulb: {
                width: 60, height: 60, res: 10, type: 'load',
                svg: `<rect width="60" height="60" fill="transparent"/><circle class="bulb-glass" cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/><path d="M 19 19 L 41 41 M 19 41 L 41 19" stroke="#333" stroke-width="2" class="bulb-cross"/><path d="M 0 30 L 15 30 M 45 30 L 60 30" stroke="#333" stroke-width="2"/>`,
                pins: [{id: 'p1', x: 0, y: 30}, {id: 'p2', x: 60, y: 30}]
            },
            resistor: {
                width: 60, height: 40, res: 10, type: 'load',
                svg: `<rect width="60" height="40" fill="transparent"/><rect x="15" y="15" width="30" height="10" fill="#fff" stroke="#333" stroke-width="2"/><path d="M 0 20 L 15 20 M 45 20 L 60 20" stroke="#333" stroke-width="2"/><text x="30" y="10" font-size="10" text-anchor="middle">10Ω</text>`,
                pins: [{id: 'p1', x: 0, y: 20}, {id: 'p2', x: 60, y: 20}]
            },
            switch: {
                width: 60, height: 40, res: 0, type: 'switch',
                svg: `<rect width="60" height="40" fill="transparent"/><path d="M 0 20 L 15 20 M 45 20 L 60 20" stroke="#333" stroke-width="2"/><circle cx="15" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/><circle cx="45" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/><line class="switch-blade" x1="15" y1="20" x2="40" y2="10" stroke="#333" stroke-width="2"/>`,
                pins: [{id: 'p1', x: 0, y: 20}, {id: 'p2', x: 60, y: 20}]
            },
            ammeter: {
                width: 60, height: 60, res: 0, type: 'meter',
                svg: `<rect width="60" height="60" fill="transparent"/><circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/><text x="30" y="35" font-size="14" font-weight="bold" text-anchor="middle">A</text><path d="M 0 30 L 15 30 M 45 30 L 60 30" stroke="#333" stroke-width="2"/>`,
                pins: [{id: 'p1', x: 0, y: 30}, {id: 'p2', x: 60, y: 30}]
            },
            voltmeter: {
                width: 60, height: 60, res: 999999, type: 'meter',
                svg: `<rect width="60" height="60" fill="transparent"/><circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/><text x="30" y="35" font-size="14" font-weight="bold" text-anchor="middle">V</text><path d="M 0 30 L 15 30 M 45 30 L 60 30" stroke="#333" stroke-width="2"/>`,
                pins: [{id: 'p1', x: 0, y: 30}, {id: 'p2', x: 60, y: 30}]
            }
        };

        function updateCanvasTransform() {
            canvasWrapper.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${canvasScale})`;
            const gridSizeScaled = gridSize * canvasScale;
            canvasContainer.style.backgroundSize = `${gridSizeScaled}px ${gridSizeScaled}px`;
            canvasContainer.style.backgroundPosition = `${canvasOffset.x}px ${canvasOffset.y}px`;
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('mode-select').addEventListener('change', (e) => {
                const faultPanel = document.getElementById('fault-panel');
                if(e.target.value === 'fault') {
                    faultPanel.classList.remove('d-none');
                } else {
                    faultPanel.classList.add('d-none');
                    document.getElementById('fault-type').value = 'none';
                }
                resetSimulation();
            });

            document.getElementById('btn-trigger-fault').addEventListener('click', () => {
                if(!isSimulating) toggleSimulation();
                else updateSimulation();
            });

            canvasContainer.addEventListener('wheel', (e) => {
                if(isSimulating) return;
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const rect = canvasContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldX = (mouseX - canvasOffset.x) / canvasScale;
                const worldY = (mouseY - canvasOffset.y) / canvasScale;
                canvasScale = Math.max(0.3, Math.min(3, canvasScale * delta));
                canvasOffset.x = mouseX - worldX * canvasScale;
                canvasOffset.y = mouseY - worldY * canvasScale;
                updateCanvasTransform();
            }, {passive: false});

            canvasContainer.addEventListener('mousedown', (e) => {
                if(isSimulating) return;
                if(e.target === canvasContainer || e.target === canvas || e.target === canvasWrapper) {
                    if(e.button === 1 || (e.button === 0 && spaceKey)) {
                        e.preventDefault();
                        isDraggingCanvas = true;
                        canvasDragStart = { x: e.clientX, y: e.clientY };
                        canvasDragStartOffset = { ...canvasOffset };
                    }
                }
            });

            document.addEventListener('mousemove', (e) => {
                if(isDraggingCanvas) {
                    e.preventDefault();
                    canvasOffset.x = canvasDragStartOffset.x + (e.clientX - canvasDragStart.x);
                    canvasOffset.y = canvasDragStartOffset.y + (e.clientY - canvasDragStart.y);
                    updateCanvasTransform();
                }
            });

            document.addEventListener('mouseup', (e) => {
                if(e.button === 1 || e.button === 0) isDraggingCanvas = false;
            });

            let spaceKey = false;
            document.addEventListener('keydown', (e) => {
                if(e.code === 'Space') {
                    spaceKey = true;
                    canvasContainer.style.cursor = 'grab';
                }
            });
            document.addEventListener('keyup', (e) => {
                if(e.code === 'Space') {
                    spaceKey = false;
                    canvasContainer.style.cursor = '';
                    isDraggingCanvas = false;
                }
            });

            let touchStartDistance = 0, touchStartScale = 1, touchStartOffset = { x: 0, y: 0 }, lastTouchCenter = { x: 0, y: 0 };

            canvasContainer.addEventListener('touchstart', (e) => {
                if(isSimulating) return;
                if(e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0], touch2 = e.touches[1];
                    touchStartDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                    touchStartScale = canvasScale;
                    touchStartOffset = { ...canvasOffset };
                    lastTouchCenter = { x: (touch1.clientX + touch2.clientX) / 2, y: (touch1.clientY + touch2.clientY) / 2 };
                } else if(e.touches.length === 1 && !draggingComp && !tempWire) {
                    const rect = canvasContainer.getBoundingClientRect();
                    const touch = e.touches[0];
                    if(touch.clientX - rect.left < 50 && touch.clientY - rect.top < 50) {
                        isDraggingCanvas = true;
                        canvasDragStart = { x: touch.clientX, y: touch.clientY };
                        canvasDragStartOffset = { ...canvasOffset };
                    }
                }
            }, {passive: false});

            canvasContainer.addEventListener('touchmove', (e) => {
                if(e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0], touch2 = e.touches[1];
                    const distance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                    const scale = touchStartScale * (distance / touchStartDistance);
                    canvasScale = Math.max(0.3, Math.min(3, scale));
                    const center = { x: (touch1.clientX + touch2.clientX) / 2, y: (touch1.clientY + touch2.clientY) / 2 };
                    const rect = canvasContainer.getBoundingClientRect();
                    const worldX = (lastTouchCenter.x - rect.left - touchStartOffset.x) / touchStartScale;
                    const worldY = (lastTouchCenter.y - rect.top - touchStartOffset.y) / touchStartScale;
                    canvasOffset.x = center.x - rect.left - worldX * canvasScale;
                    canvasOffset.y = center.y - rect.top - worldY * canvasScale;
                    updateCanvasTransform();
                } else if(isDraggingCanvas && e.touches.length === 1) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    canvasOffset.x = canvasDragStartOffset.x + (touch.clientX - canvasDragStart.x);
                    canvasOffset.y = canvasDragStartOffset.y + (touch.clientY - canvasDragStart.y);
                    updateCanvasTransform();
                }
            }, {passive: false});

            canvasContainer.addEventListener('touchend', () => isDraggingCanvas = false);

            canvas.addEventListener('touchstart', handleDragStart, {passive: false});
            document.addEventListener('touchmove', handleDragMove, {passive: false});
            document.addEventListener('touchend', handleDragEnd);
            canvas.addEventListener('mousedown', handleDragStart);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);

            initPaletteDrag();
            updateCanvasTransform();
        });

        function showGuide() { new bootstrap.Modal(document.getElementById('guideModal')).show(); }

        function initPaletteDrag() {
            const paletteItems = document.querySelectorAll('.palette-item');
            paletteItems.forEach(item => {
                let holdTimer = null, isHolding = false;
                const startPaletteDrag = (pt, type) => {
                    if(isSimulating) return alert('请先停止实验再修改电路');
                    const def = CompDefs[type];
                    const world = screenToWorld(pt.x, pt.y);
                    
                    let pinOffsetX = def.pins[0].x;
                    let pinOffsetY = def.pins[0].y;
                    const comp = {
                        id: 'comp_' + (++compCounter),
                        type: type,
                        x: Math.round((world.x - def.width / 2 + pinOffsetX) / gridSize) * gridSize - pinOffsetX,
                        y: Math.round((world.y - def.height / 2 + pinOffsetY) / gridSize) * gridSize - pinOffsetY,
                        def: def,
                        isClosed: false
                    };
                    components.push(comp);
                    draggingComp = comp;
                    dragOffset = { x: def.width / 2, y: def.height / 2 };
                    trashCan.classList.add('visible');
                    renderComponents();
                };

                item.addEventListener('touchstart', (e) => {
                    if(isSimulating) return;
                    const pt = getEventPoint(e);
                    isHolding = false;
                    holdTimer = setTimeout(() => {
                        isHolding = true;
                        startPaletteDrag(pt, item.getAttribute('data-type'));
                    }, 200); 
                }, {passive: true});

                item.addEventListener('touchmove', (e) => {
                    if (!isHolding && holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
                    if (isHolding) { e.preventDefault(); handleDragMove(e); }
                }, {passive: false});

                const cancelTouch = (e) => {
                    if (holdTimer) clearTimeout(holdTimer);
                    if (isHolding) { handleDragEnd(e); isHolding = false; }
                };
                item.addEventListener('touchend', cancelTouch);
                item.addEventListener('touchcancel', cancelTouch);

                item.addEventListener('mousedown', (e) => {
                    if(isSimulating) return alert('请先停止实验再修改电路');
                    e.preventDefault();
                    startPaletteDrag(getEventPoint(e), item.getAttribute('data-type'));
                });
            });
        }

        function renderComponents() {
            layerComps.innerHTML = '';
            components.forEach(comp => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'component-group');
                g.setAttribute('transform', `translate(${comp.x}, ${comp.y})`);
                g.setAttribute('data-id', comp.id);
                
                let svgContent = comp.def.svg;
                if(comp.type === 'switch' && comp.isClosed) {
                    svgContent = svgContent.replace('y2="10"', 'y2="20"');
                }
                g.innerHTML = svgContent;

                if(comp.type === 'switch') {
                    g.addEventListener('dblclick', (e) => toggleSwitch(comp.id, e));
                    let touchStartTime = 0;
                    g.addEventListener('touchstart', () => touchStartTime = Date.now());
                    g.addEventListener('touchend', (e) => {
                        if(Date.now() - touchStartTime < 200 && !draggingComp) toggleSwitch(comp.id, e);
                    });
                }

                comp.def.pins.forEach(pin => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    const pinId = `${comp.id}_${pin.id}`;
                    circle.setAttribute('class', `terminal ${pin.type === 'negative' ? 'negative' : ''}`);
                    circle.setAttribute('cx', pin.x);
                    circle.setAttribute('cy', pin.y);
                    circle.setAttribute('r', 5);
                    circle.setAttribute('data-pinid', pinId);
                    circle.setAttribute('data-compid', comp.id);
                    g.appendChild(circle);
                });
                
                layerComps.appendChild(g);
            });
        }

        function toggleSwitch(id, e) {
            if(e) e.stopPropagation();
            const comp = components.find(c => c.id === id);
            if(comp) {
                comp.isClosed = !comp.isClosed;
                renderComponents();
                if(isSimulating) updateSimulation();
            }
        }

        function getPinCoords(pinId) {
            const lastIndex = pinId.lastIndexOf('_');
            const actualCompId = pinId.substring(0, lastIndex);
            const actualPinId = pinId.substring(lastIndex + 1);
            const c = components.find(x => x.id === actualCompId);
            if(!c) return {x:0, y:0};
            const p = c.def.pins.find(x => x.id === actualPinId);
            return { x: Math.round((c.x + p.x) / gridSize) * gridSize, y: Math.round((c.y + p.y) / gridSize) * gridSize };
        }

        // --- 核心：连线自动正交寻路与重绘 ---
        function getPinDir(pinId) {
            const cId = pinId.substring(0, pinId.lastIndexOf('_'));
            const pId = pinId.substring(pinId.lastIndexOf('_') + 1);
            const comp = components.find(c => c.id === cId);
            if(!comp) return {x: 1, y: 0};
            const pin = comp.def.pins.find(p => p.id === pId);
            if(pin && pin.dir) return pin.dir;
            if(pin && pin.x < comp.def.width / 2) return {x: -1, y: 0};
            return {x: 1, y: 0};
        }

        function findAStarPath(start, end) {
            const gridStart = {x: Math.round(start.x/gridSize), y: Math.round(start.y/gridSize)};
            const gridEnd = {x: Math.round(end.x/gridSize), y: Math.round(end.y/gridSize)};

            if(gridStart.x === gridEnd.x && gridStart.y === gridEnd.y) return [start];

            let minX = Math.min(gridStart.x, gridEnd.x) - 10;
            let maxX = Math.max(gridStart.x, gridEnd.x) + 10;
            let minY = Math.min(gridStart.y, gridEnd.y) - 10;
            let maxY = Math.max(gridStart.y, gridEnd.y) + 10;

            components.forEach(c => {
                let gx = Math.floor(c.x / gridSize);
                let gy = Math.floor(c.y / gridSize);
                let gw = Math.ceil(c.def.width / gridSize);
                let gh = Math.ceil(c.def.height / gridSize);
                minX = Math.min(minX, gx - 2);
                maxX = Math.max(maxX, gx + gw + 2);
                minY = Math.min(minY, gy - 2);
                maxY = Math.max(maxY, gy + gh + 2);
            });

            const isObstacle = (x, y) => {
                return components.some(c => {
                    let cx = c.x / gridSize;
                    let cy = c.y / gridSize;
                    let cw = c.def.width / gridSize;
                    let ch = c.def.height / gridSize;
                    return x > cx && x < cx + cw && y > cy && y < cy + ch;
                });
            };

            let openSet = [gridStart];
            let cameFrom = new Map();
            let gScore = new Map();
            let fScore = new Map();
            
            const hash = (p) => `${p.x},${p.y}`;
            gScore.set(hash(gridStart), 0);
            fScore.set(hash(gridStart), Math.abs(gridStart.x - gridEnd.x) + Math.abs(gridStart.y - gridEnd.y));

            const dirs = [{x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0}];
            let iter = 0;

            while(openSet.length > 0 && iter < 3000) {
                iter++;
                let currIdx = 0;
                let minF = fScore.get(hash(openSet[0]));
                for(let i=1; i<openSet.length; i++) {
                    let f = fScore.get(hash(openSet[i]));
                    if(f < minF) { minF = f; currIdx = i; }
                }

                let current = openSet.splice(currIdx, 1)[0];
                let currentHash = hash(current);

                if (current.x === gridEnd.x && current.y === gridEnd.y) {
                    let path = [current];
                    while(cameFrom.has(hash(path[0]))) {
                        path.unshift(cameFrom.get(hash(path[0])));
                    }
                    let simplifiedPath = [path[0]];
                    let lastDir = null;
                    for(let i=1; i<path.length; i++){
                        let dx = path[i].x - path[i-1].x;
                        let dy = path[i].y - path[i-1].y;
                        if(lastDir && (lastDir.x !== dx || lastDir.y !== dy)) {
                            simplifiedPath.push(path[i-1]);
                        }
                        lastDir = {x: dx, y: dy};
                    }
                    simplifiedPath.push(path[path.length-1]);
                    return simplifiedPath.map(p => ({x: p.x * gridSize, y: p.y * gridSize}));
                }

                for(let dir of dirs) {
                    let neighbor = {x: current.x + dir.x, y: current.y + dir.y};
                    if(neighbor.x < minX || neighbor.x > maxX || neighbor.y < minY || neighbor.y > maxY) continue;

                    let moveCost = isObstacle(neighbor.x, neighbor.y) ? 100 : 1;
                    let turnPenalty = 0;
                    if (cameFrom.has(currentHash)) {
                        let prev = cameFrom.get(currentHash);
                        let prevDir = {x: current.x - prev.x, y: current.y - prev.y};
                        if (prevDir.x !== dir.x || prevDir.y !== dir.y) turnPenalty = 5; 
                    }

                    let t_gScore = gScore.get(currentHash) + moveCost + turnPenalty;
                    let neighborHash = hash(neighbor);

                    if (!gScore.has(neighborHash) || t_gScore < gScore.get(neighborHash)) {
                        cameFrom.set(neighborHash, current);
                        gScore.set(neighborHash, t_gScore);
                        fScore.set(neighborHash, t_gScore + Math.abs(neighbor.x - gridEnd.x) + Math.abs(neighbor.y - gridEnd.y));
                        if (!openSet.some(p => p.x === neighbor.x && p.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return null;
        }

        function getPathData(p1Id, c1, p2Id, c2) {
            let dir1 = getPinDir(p1Id);
            let dir2 = p2Id ? getPinDir(p2Id) : null;

            let ext1 = {x: c1.x + dir1.x * gridSize, y: c1.y + dir1.y * gridSize};
            let ext2 = dir2 ? {x: c2.x + dir2.x * gridSize, y: c2.y + dir2.y * gridSize} : {x: Math.round(c2.x/gridSize)*gridSize, y: Math.round(c2.y/gridSize)*gridSize};

            let path = findAStarPath(ext1, ext2);
            if (!path) {
                let midX = Math.round((ext1.x + ext2.x) / 2 / gridSize) * gridSize;
                path = [ext1, {x: midX, y: ext1.y}, {x: midX, y: ext2.y}, ext2];
            }
            
            path.unshift(c1);
            if(dir2) path.push(c2); else path.push({x: c2.x, y: c2.y}); 

            let d = `M ${path[0].x} ${path[0].y}`;
            for(let i=1; i<path.length; i++) {
                d += ` L ${path[i].x} ${path[i].y}`;
            }
            return d;
        }

        function renderWires() {
            layerWires.innerHTML = '';
            wires.forEach(wire => {
                const c1 = getPinCoords(wire.p1);
                const c2 = getPinCoords(wire.p2);
                
                const pathData = getPathData(wire.p1, c1, wire.p2, c2);

                const wireGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                const clickArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                clickArea.setAttribute('d', pathData);
                clickArea.setAttribute('class', 'wire-click-area');
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('class', 'wire');
                
                const removeWire = (e) => {
                    e.stopPropagation();
                    if(isSimulating) return;
                    wires = wires.filter(w => w.id !== wire.id);
                    renderWires();
                };
                clickArea.addEventListener('click', removeWire);
                clickArea.addEventListener('touchstart', removeWire);
                path.addEventListener('click', removeWire);
                path.addEventListener('touchstart', removeWire);
                
                wireGroup.appendChild(clickArea);
                wireGroup.appendChild(path);
                layerWires.appendChild(wireGroup);
            });

            if (tempWire) {
                const pathData = getPathData(tempWire.p1, {x: tempWire.startX, y: tempWire.startY}, tempWire.snapPin, {x: tempWire.endX, y: tempWire.endY});
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('class', 'wire');
                path.style.strokeDasharray = '5,5';
                path.style.pointerEvents = 'none';
                path.style.opacity = '0.7';
                layerWires.appendChild(path);
            }
        }

        function getEventPoint(e) {
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        function screenToWorld(screenX, screenY) {
            const rect = canvasContainer.getBoundingClientRect();
            return {
                x: (screenX - rect.left - canvasOffset.x) / canvasScale,
                y: (screenY - rect.top - canvasOffset.y) / canvasScale
            };
        }

        function handleDragStart(e) {
            if(isSimulating) return;

            if (e.target.classList && e.target.classList.contains('terminal')) {
                e.stopPropagation(); 
                const pinId = e.target.getAttribute('data-pinid');
                const startCoords = getPinCoords(pinId);
                
                tempWire = {
                    p1: pinId, startX: startCoords.x, startY: startCoords.y,
                    endX: startCoords.x, endY: startCoords.y, snapPin: null
                };

                allPinsCache = [];
                const sourceCompId = pinId.substring(0, pinId.lastIndexOf('_'));
                components.forEach(c => {
                    if(c.id === sourceCompId) return;
                    c.def.pins.forEach(p => {
                        const pid = `${c.id}_${p.id}`;
                        allPinsCache.push({
                            id: pid, coords: getPinCoords(pid),
                            element: document.querySelector(`[data-pinid="${pid}"]`)
                        });
                    });
                });
                return;
            }

            const target = e.target.closest ? e.target.closest('.component-group') : null;
            if (target && !e.target.classList.contains('terminal')) {
                const id = target.getAttribute('data-id');
                draggingComp = components.find(c => c.id === id);
                if (draggingComp) {
                    const pt = getEventPoint(e);
                    const world = screenToWorld(pt.x, pt.y);
                    dragOffset.x = world.x - draggingComp.x;
                    dragOffset.y = world.y - draggingComp.y;
                    trashCan.classList.add('visible'); 
                }
            }
        }

        function handleDragMove(e) {
            if (!tempWire && !draggingComp) return;
            e.preventDefault();
            if (tempWire) {
                const pt = getEventPoint(e);
                const world = screenToWorld(pt.x, pt.y);
                let minDist = 30 / canvasScale;
                let closestPin = null;

                allPinsCache.forEach(p => {
                    if(p.element) p.element.classList.remove('active');
                    let dx = world.x - p.coords.x;
                    let dy = world.y - p.coords.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < minDist) { minDist = dist; closestPin = p; }
                });

                if (closestPin) {
                    tempWire.endX = closestPin.coords.x; tempWire.endY = closestPin.coords.y;
                    tempWire.snapPin = closestPin.id;
                    if(closestPin.element) closestPin.element.classList.add('active');
                } else {
                    tempWire.endX = world.x; tempWire.endY = world.y;
                    tempWire.snapPin = null;
                }
                renderWires();
                return;
            }

            if (draggingComp) {
                const pt = getEventPoint(e);
                const world = screenToWorld(pt.x, pt.y);
                const trashRect = trashCan.getBoundingClientRect();
                if (pt.x > trashRect.left && pt.x < trashRect.right && pt.y > trashRect.top && pt.y < trashRect.bottom) {
                    trashCan.classList.add('active'); isHoveringTrash = true;
                } else {
                    trashCan.classList.remove('active'); isHoveringTrash = false;
                }

                let pinOffsetX = draggingComp.def.pins[0].x;
                let pinOffsetY = draggingComp.def.pins[0].y;
                let rawX = world.x - dragOffset.x;
                let rawY = world.y - dragOffset.y;
                let snapX = Math.round((rawX + pinOffsetX) / gridSize) * gridSize - pinOffsetX;
                let snapY = Math.round((rawY + pinOffsetY) / gridSize) * gridSize - pinOffsetY;
                
                draggingComp.x = snapX; draggingComp.y = snapY;
                const compGroup = document.querySelector(`g[data-id="${draggingComp.id}"]`);
                if (compGroup) compGroup.setAttribute('transform', `translate(${draggingComp.x}, ${draggingComp.y})`);
                renderWires();
            }
        }

        function handleDragEnd(e) {
            if (tempWire) {
                allPinsCache.forEach(p => { if(p.element) p.element.classList.remove('active'); });
                if (tempWire.snapPin) {
                    const fromComp = tempWire.p1.substring(0, tempWire.p1.lastIndexOf('_'));
                    const toComp = tempWire.snapPin.substring(0, tempWire.snapPin.lastIndexOf('_'));
                    const sameComp = fromComp === toComp;
                    const exist = wires.find(w => (w.p1 === tempWire.p1 && w.p2 === tempWire.snapPin) || (w.p2 === tempWire.p1 && w.p1 === tempWire.snapPin));
                    if(!exist && !sameComp) wires.push({ id: 'w_'+Date.now(), p1: tempWire.p1, p2: tempWire.snapPin });
                }
                tempWire = null; allPinsCache = [];
                renderWires();
                return;
            }

            if (draggingComp) {
                if (isHoveringTrash) {
                    components = components.filter(c => c.id !== draggingComp.id);
                    wires = wires.filter(w => !w.p1.startsWith(draggingComp.id) && !w.p2.startsWith(draggingComp.id));
                }
                draggingComp = null; isHoveringTrash = false;
                trashCan.classList.remove('visible', 'active');
                renderComponents(); renderWires();
            }
        }

        function resetCanvas() {
            if(confirm("确定清空画布并重置吗？")) {
                components = []; wires = []; compCounter = 0;
                resetSimulation(); renderComponents(); renderWires();
            }
        }

        function resetSimulation() {
            isSimulating = false;
            conductingWireIds = new Set();
            document.getElementById('btn-simulate').innerText = "启动实验";
            document.getElementById('btn-simulate').classList.replace('btn-warning', 'btn-primary');
            setStatus('idle', '等待操作 (未连接电源)');
            document.querySelectorAll('.bulb-glass, .bulb-cross').forEach(el => el.classList.remove('active'));
            renderWires();
        }

        function toggleSimulation() {
            if(isSimulating) {
                resetSimulation();
            } else {
                isSimulating = true;
                renderComponents();
                document.getElementById('btn-simulate').innerText = "停止实验";
                document.getElementById('btn-simulate').classList.replace('btn-primary', 'btn-warning');
                updateSimulation();
            }
        }

        function setStatus(type, text) {
            statusDisplay.className = `status-box status-${type}`;
            statusDisplay.innerText = text;
        }

        function buildGraph(opts = {}) {
            let graph = {};
            const addEdge = (u, v, res, comp = null) => {
                if(!graph[u]) graph[u] = []; if(!graph[v]) graph[v] = [];
                graph[u].push({to: v, res: res, comp: comp}); graph[v].push({to: u, res: res, comp: comp});
            };

            components.forEach(c => {
                if(c.type === 'battery') return;
                const p1 = `${c.id}_p1`, p2 = `${c.id}_p2`;
                let res = c.def.res;
                if(c.type === 'switch') res = c.isClosed ? 0 : 999999;
                if(opts.applianceShort && (c.type === 'bulb' || c.type === 'resistor')) res = 0;
                addEdge(p1, p2, res, c);
            });

            let effectiveWires = opts.breakWireIndex !== undefined && opts.breakWireIndex >= 0 && opts.breakWireIndex < wires.length ? 
                wires.filter((_, i) => i !== opts.breakWireIndex) : wires;
            effectiveWires.forEach(w => addEdge(w.p1, w.p2, 0, null));

            if(opts.powerShort) {
                const battery = components.find(c => c.type === 'battery');
                if(battery) addEdge(`${battery.id}_p1`, `${battery.id}_p2`, 0, null);
            }
            return { graph, addEdge };
        }

        function dijkstra(graph, startPin, endPin) {
            let dist = {}, prev = {};
            for(let node in graph) dist[node] = Infinity;
            dist[startPin] = 0;
            let pq = [startPin], visited = {};
            while(pq.length > 0) {
                pq.sort((a,b) => dist[a] - dist[b]);
                let u = pq.shift();
                if(visited[u]) continue;
                visited[u] = true;
                if(!graph[u]) continue;
                for(let edge of graph[u]) {
                    let alt = dist[u] + edge.res;
                    if(alt < dist[edge.to]) {
                        dist[edge.to] = alt;
                        prev[edge.to] = { from: u, comp: edge.comp };
                        pq.push(edge.to);
                    }
                }
            }
            return { dist, prev };
        }

        function findAllReachableNodes(graph, startPin) {
            let visited = new Set(), queue = [startPin];
            visited.add(startPin);
            while(queue.length > 0) {
                let u = queue.shift();
                if(!graph[u]) continue;
                for(let edge of graph[u]) {
                    if(!visited.has(edge.to) && edge.res < 999999) {
                        visited.add(edge.to); queue.push(edge.to);
                    }
                }
            }
            return visited;
        }

        function findAllConductingComps(graph, startPin, endPin) {
            let reachableFromStart = findAllReachableNodes(graph, startPin);
            if(!reachableFromStart.has(endPin)) return { comps: new Set(), wireEdges: new Set(), totalRes: Infinity };

            let reverseReachable = findAllReachableNodes(graph, endPin);
            let conductingNodes = new Set();
            for(let node of reachableFromStart) if(reverseReachable.has(node)) conductingNodes.add(node);

            let conductingComps = new Set(), conductingEdges = new Set(), hasLoad = false;

            for(let node of conductingNodes) {
                if(!graph[node]) continue;
                for(let edge of graph[node]) {
                    if(conductingNodes.has(edge.to) && edge.res < 999999) {
                        conductingEdges.add(node + '|' + edge.to);
                        if(edge.comp) {
                            conductingComps.add(edge.comp);
                            if(edge.comp.type === 'bulb' || edge.comp.type === 'resistor') hasLoad = true;
                        }
                    }
                }
            }

            let { dist } = dijkstra(graph, startPin, endPin);
            return { comps: conductingComps, wireEdges: conductingEdges, totalRes: dist[endPin], hasLoad };
        }

        // 核心修复1：使用真实的物理等电位网络去寻找并联（防误判本身短路的情况）
        function getZeroResCluster(graph, startPin, ignoreCompId) {
            let cluster = new Set();
            let queue = [startPin];
            cluster.add(startPin);
            while(queue.length > 0) {
                let u = queue.shift();
                if(!graph[u]) continue;
                for(let edge of graph[u]) {
                    if(edge.comp && edge.comp.id === ignoreCompId) continue; // 屏蔽电表自身通道
                    if(edge.res === 0 && !cluster.has(edge.to)) {
                        cluster.add(edge.to);
                        queue.push(edge.to);
                    }
                }
            }
            return cluster;
        }

        // 核心修复2：基于节点电压差（dijkstra dist差值）来准确测算测量电压
        function checkRangeError(battery, totalRes, dist) {
            if(!battery || totalRes <= 0 || totalRes >= 999999) return [];
            const voltage = 1.5, current = voltage / totalRes;
            let faults = [];
            components.forEach(c => {
                if(c.type === 'ammeter') {
                    if(current > 0.6) faults.push(`电流表(${c.id})量程过小(电流${current.toFixed(2)}A > 0.6A量程)，可能烧毁`);
                    else if(current < 0.02) faults.push(`电流表(${c.id})偏转过小(电流${current.toFixed(3)}A)，应换小量程`);
                }
                if(c.type === 'voltmeter') {
                    let cp1 = `${c.id}_p1`, cp2 = `${c.id}_p2`;
                    let d1 = dist[cp1] !== undefined ? dist[cp1] : Infinity;
                    let d2 = dist[cp2] !== undefined ? dist[cp2] : Infinity;
                    let measuredV = 0;
                    if(d1 !== Infinity && d2 !== Infinity) {
                        measuredV = current * Math.abs(d1 - d2);
                    }
                    if(measuredV > 3) faults.push(`电压表(${c.id})量程过小(测得电压${measuredV.toFixed(2)}V > 3V量程)，可能烧毁`);
                    else if(measuredV > 0 && measuredV < 0.1) faults.push(`电压表(${c.id})偏转过小(测得电压${measuredV.toFixed(2)}V)，应换小量程`);
                }
            });
            return faults;
        }

        function autoDetectFaults(battery) {
            let allFaults = [];
            const batP1 = `${battery.id}_p1`, batP2 = `${battery.id}_p2`;
            let { graph } = buildGraph({}), { dist } = dijkstra(graph, batP1, batP2);
            let totalRes = dist[batP2];

            if(totalRes === 0) {
                let allResult = findAllConductingComps(graph, batP1, batP2);
                allFaults.push(allResult.hasLoad ? '⚠️ 用电器被短路！有导线直接绕过了用电器。' : '⚠️ 电源短路！电池正负极之间无用电器，会烧毁电源。');
            }

            if(totalRes >= 999999) {
                let openSwitches = components.filter(c => c.type === 'switch' && !c.isClosed);
                if(openSwitches.length > 0) allFaults.push('断路: 开关未闭合。');

                let { graph: closedGraph } = buildGraph({});
                components.forEach(c => {
                    if(c.type === 'switch' && !c.isClosed) {
                        const p1 = `${c.id}_p1`, p2 = `${c.id}_p2`;
                        if(!closedGraph[p1]) closedGraph[p1] = []; if(!closedGraph[p2]) closedGraph[p2] = [];
                        closedGraph[p1].push({to: p2, res: 0, comp: c}); closedGraph[p2].push({to: p1, res: 0, comp: c});
                    }
                });
                if(dijkstra(closedGraph, batP1, batP2).dist[batP2] >= 999999) allFaults.push('断路: 即使闭合所有开关，电路仍不连通，请检查导线。');
            }

            if(totalRes > 0 && totalRes < 999999) allFaults = allFaults.concat(checkRangeError(battery, totalRes, dist));

            components.forEach(c => {
                if(c.type === 'ammeter') {
                    const cp1 = `${c.id}_p1`, cp2 = `${c.id}_p2`;
                    // 找出与电流表左右两端相连的物理“等电位节点集合” (不通过电流表自身)
                    let cluster1 = getZeroResCluster(graph, cp1, c.id);
                    let cluster2 = getZeroResCluster(graph, cp2, c.id);

                    // 如果自身被短路，则 cluster1 中会包含 cp2，此时并非在测量用电器的“并联”
                    if (!cluster1.has(cp2)) {
                        components.forEach(mc => {
                            if(mc.type === 'bulb' || mc.type === 'resistor') {
                                let mp1 = `${mc.id}_p1`, mp2 = `${mc.id}_p2`;
                                // 当用电器的两端分别被囊括在了电流表的两端电位网络中时，才属于真“并联”
                                if ((cluster1.has(mp1) && cluster2.has(mp2)) || (cluster1.has(mp2) && cluster2.has(mp1))) {
                                    allFaults.push(`电流表(${c.id})并联在了${mc.type === 'bulb' ? '灯泡' : '定值电阻'}(${mc.id})两端，应串联使用。`);
                                }
                            }
                        });
                    }
                }
                if(c.type === 'voltmeter') {
                    let { graph: testGraph } = buildGraph({});
                    delete testGraph[`${c.id}_p1`]; delete testGraph[`${c.id}_p2`];
                    for(let node in testGraph) testGraph[node] = testGraph[node].filter(e => e.to !== `${c.id}_p1` && e.to !== `${c.id}_p2`);
                    if(dijkstra(testGraph, batP1, batP2).dist[batP2] >= 999999) allFaults.push(`电压表(${c.id})串联在了电路中，应并联使用。`);
                }
            });
            return allFaults;
        }

        function updateSimulation() {
            const faultSelect = document.getElementById('fault-type').value;
            const isFaultMode = document.getElementById('mode-select').value === 'fault';
            const battery = components.find(c => c.type === 'battery');
            if(!battery) return setStatus('error', '未检测到电源，电路断路。');

            const batP1 = `${battery.id}_p1`, batP2 = `${battery.id}_p2`;
            
            let opts = {};
            if(isFaultMode && faultSelect !== 'none') {
                if(faultSelect === 'power_short') opts.powerShort = true;
                if(faultSelect === 'appliance_short') opts.applianceShort = true;
                if(faultSelect === 'wire_break' && wires.length > 0) opts.breakWireIndex = Math.floor(Math.random() * wires.length);
            }

            let { graph } = buildGraph(opts);
            if(!graph[batP1]) graph[batP1] = []; if(!graph[batP2]) graph[batP2] = [];
            let { dist } = dijkstra(graph, batP1, batP2);
            let totalRes = dist[batP2];

            document.querySelectorAll('.bulb-glass, .bulb-cross').forEach(el => el.classList.remove('active'));
            conductingWireIds = new Set();

            if(isFaultMode && faultSelect !== 'none') {
                if(faultSelect === 'range_error') {
                    let { graph: normalGraph } = buildGraph({}), { dist: normalDist } = dijkstra(normalGraph, batP1, batP2);
                    let normalRes = normalDist[batP2];
                    if(normalRes > 0 && normalRes < 999999) {
                        lightBulbsAll(normalGraph, batP1, batP2); conductingWireIds = findConductingWiresAll(normalGraph, batP1, batP2); renderWires();
                        let voltage = 1.5, current = voltage / normalRes, msgs = [];
                        components.forEach(c => {
                            if(c.type === 'ammeter') msgs.push(`电流表(${c.id}): 电流${current.toFixed(3)}A，${current > 0.6 ? '超量程' : current < 0.02 ? '偏转太小' : '正常'}`);
                            if(c.type === 'voltmeter') {
                                let cp1 = `${c.id}_p1`, cp2 = `${c.id}_p2`;
                                let d1 = normalDist[cp1] !== undefined ? normalDist[cp1] : Infinity;
                                let d2 = normalDist[cp2] !== undefined ? normalDist[cp2] : Infinity;
                                let measuredV = (d1 !== Infinity && d2 !== Infinity) ? current * Math.abs(d1 - d2) : 0;
                                msgs.push(`电压表(${c.id}): 测得电压约${measuredV.toFixed(1)}V，若量程3V则${measuredV > 3 ? '超量程' : '正常'}`);
                            }
                        });
                        if(msgs.length === 0) return setStatus('error', '⚠️ 电路中没有电表，无法模拟量程故障。');
                        return setStatus('error', '⚠️ 量程分析:\n' + msgs.join('\n'));
                    }
                    return setStatus('error', '⚠️ 电路未导通，无法分析量程。');
                }
                if(faultSelect === 'wire_break') {
                    if(totalRes >= 999999) { renderWires(); return setStatus('error', '⚠️ 故障: 导线断路！电路中有一根导线断开，电路不通。'); }
                    else {
                        lightBulbsAll(graph, batP1, batP2); conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires();
                        return setStatus('error', '⚠️ 故障: 导线断路！断开的导线未影响主回路，但部分支路可能失效。');
                    }
                }
                if(totalRes >= 999999) { renderWires(); return setStatus('idle', '状态: 断路 (开关未闭合或线路未连通)'); }
                else if(totalRes === 0) {
                    let allResult = findAllConductingComps(graph, batP1, batP2);
                    if(!allResult.hasLoad) { renderWires(); return setStatus('error', '⚠️ 警告: 电源短路！请立即断开开关。'); }
                    else { conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires(); return setStatus('error', '⚠️ 用电器被短路！有导线直接绕过了用电器。灯泡不亮。'); }
                } else {
                    lightBulbsAll(graph, batP1, batP2); conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires();
                    return setStatus('success', '状态: 导通。实验正常进行。');
                }
            }

            if(isFaultMode && faultSelect === 'none') {
                let detectedFaults = autoDetectFaults(battery);
                if(detectedFaults.length > 0) {
                    if(totalRes > 0 && totalRes < 999999) { lightBulbsAll(graph, batP1, batP2); conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires(); }
                    return setStatus('error', '🔍 自动识别:\n' + detectedFaults.join('\n'));
                }
            }

            if(totalRes >= 999999) { renderWires(); setStatus('idle', '状态: 断路 (开关未闭合或线路未连通)'); }
            else if(totalRes === 0) {
                let allResult = findAllConductingComps(graph, batP1, batP2);
                if(!allResult.hasLoad) { renderWires(); setStatus('error', '⚠️ 警告: 电源短路！请立即断开开关。'); }
                else { conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires(); setStatus('error', '⚠️ 用电器被短路！有导线直接绕过了用电器。'); }
            } else {
                lightBulbsAll(graph, batP1, batP2); conductingWireIds = findConductingWiresAll(graph, batP1, batP2); renderWires();
                setStatus('success', '状态: 导通。实验正常进行。');
            }
        }

        function lightBulbsAll(graph, startPin, endPin) {
            let result = findAllConductingComps(graph, startPin, endPin);
            for(let comp of result.comps) {
                if(comp.type === 'bulb') {
                    const compGroup = document.querySelector(`g[data-id="${comp.id}"]`);
                    if(compGroup) {
                        compGroup.querySelector('.bulb-glass').classList.add('active');
                        let cross = compGroup.querySelector('.bulb-cross');
                        if(cross) cross.classList.add('active');
                    }
                }
            }
        }

        function findConductingWiresAll(graph, startPin, endPin) {
            let result = findAllConductingComps(graph, startPin, endPin);
            let ids = new Set();
            wires.forEach(w => {
                if(result.wireEdges.has(w.p1 + '|' + w.p2) || result.wireEdges.has(w.p2 + '|' + w.p1)) ids.add(w.id);
            });
            return ids;
        }
    </script>
</body>
</html>