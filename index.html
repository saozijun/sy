<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç‰©ç†ç”µè·¯å®éªŒ</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        :root {
            --grid-size: 20px;
            --primary-color: #0d6efd;
            --wire-color: #333;
            --canvas-bg: #f8f9fa;
        }
        body {
            overscroll-behavior-y: none;
            touch-action: pan-x pan-y;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            display: flex;
            flex-direction: column;
            height: 100dvh;
            margin: 0;
            background-color: #e9ecef;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        /* é¡¶éƒ¨å¯¼èˆªä¸æ§åˆ¶åŒº */
        .header-area {
            background: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            z-index: 10;
            padding: 10px;
        }
        /* å…ƒä»¶åº“æ°´å¹³æ»šåŠ¨åŒº */
        #palette-wrapper {
            background: #fff;
            border-bottom: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            transition: max-height 0.3s ease;
        }
        .component-palette {
            display: flex;
            overflow-x: auto;
            white-space: nowrap;
            padding: 10px;
            gap: 10px;
            -webkit-overflow-scrolling: touch;
        }
        .palette-item {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 70px;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
            touch-action: pan-x;
        }
        .palette-item:active { background-color: #e9ecef; }
        .palette-item svg { width: 40px; height: 40px; margin-bottom: 5px; pointer-events: none; }
        .palette-item span { font-size: 12px; color: #495057; pointer-events: none; }
        #palette-toggle {
            cursor: pointer;
            font-size: 12px;
            color: #6c757d;
            padding: 6px 0;
            text-align: center;
            background-color: #f8f9fa;
            border-top: 1px solid #eee;
        }
        #palette-toggle:hover { background-color: #e2e6ea; }
        #palette-toggle svg {
            pointer-events: none;
        }
        #palette-toggle.collapsed svg {
            transform: rotate(180deg);
        }
        
        /* æ ¸å¿ƒç”»å¸ƒåŒº */
        .canvas-container {
            flex: 1;
            position: relative;
            background-color: var(--canvas-bg);
            background-image:
                linear-gradient(to right, #ddd 1px, transparent 1px),
                linear-gradient(to bottom, #ddd 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            background-position: 0 0;
            overflow: hidden;
            touch-action: none;
        }
        .canvas-wrapper {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            transition: none;
        }
        #circuit-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* åƒåœ¾æ¡¶åŒº */
        .trash-can {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            background-color: rgba(220, 53, 69, 0.15);
            color: #dc3545;
            border: 2px dashed #dc3545;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: all 0.2s ease;
            opacity: 0;
            pointer-events: none;
            transform: scale(0.8);
        }
        .trash-can.visible {
            opacity: 1;
            transform: scale(1);
        }
        .trash-can.active {
            transform: scale(1.2);
            background-color: #dc3545;
            color: #fff;
            border-style: solid;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }

        /* ç»ƒä¹ ä»»åŠ¡æµ®çª— */
        #practice-panel {
            pointer-events: auto;
            transition: all 0.3s ease;
        }
        #practice-panel button, #practice-panel select {
            pointer-events: auto;
        }
        #practice-panel.collapsed .practice-content {
            display: none;
        }
        #practice-panel .toggle-btn {
            cursor: pointer;
            user-select: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease;
        }
        #practice-panel.collapsed .toggle-btn {
            transform: rotate(180deg);
        }
        #practice-panel .toggle-btn svg {
            pointer-events: none;
        }
        @media (max-width: 768px) {
            #practice-panel {
                width: 280px !important;
            }
        }

        /* SVG æ ·å¼ */
        .wire { stroke: var(--wire-color); stroke-width: 3; fill: none; stroke-linejoin: round; transition: stroke 0.3s; }
        .wire-click-area { stroke: transparent; stroke-width: 40; fill: none; cursor: pointer; }
        
        .component-group { cursor: grab; }
        .component-group:active { cursor: grabbing; }
        .terminal { fill: #dc3545; stroke: #fff; stroke-width: 2; cursor: crosshair; transition: r 0.2s; }
        .terminal.negative { fill: #0dcaf0; }
        .terminal:hover, .terminal.active { r: 8; stroke: #ffc107; stroke-width: 3; }
        
        /* ç¯æ³¡å‘å…‰æ•ˆæœ */
        .bulb-glass { fill: #fff; transition: all 0.3s ease; }
        .bulb-cross { stroke: #333; transition: all 0.3s ease; }
        .bulb-glass.active {
            fill: #fff9c4;
            filter: drop-shadow(0 0 8px #ffeb3b);
            stroke: #fbc02d;
        }
        .bulb-cross.active { stroke: #fbc02d; }
        
        /* è¯»æ•°æ˜¾ç¤ºæ–‡æœ¬ */
        .meter-reading { font-family: monospace; font-weight: bold; pointer-events: none; }

        /* çŠ¶æ€ä¸æ§åˆ¶æ  */
        .footer-area {
            background: #fff;
            padding: 10px;
            border-top: 1px solid #ddd;
            z-index: 10;
        }
        .status-box {
            font-size: 14px;
            font-weight: bold;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        .status-idle { background: #e9ecef; color: #495057; }
        .status-success { background: #d1e7dd; color: #0f5132; }
        .status-error { background: #f8d7da; color: #842029; }
    </style>
</head>
<body>

    <!-- é¡¶éƒ¨æ§åˆ¶åŒº -->
    <div class="header-area d-flex justify-content-between align-items-center">
        <h5 class="m-0 text-truncate" style="max-width: 25%;">ç‰©ç†ç”µè·¯å®éªŒ</h5>
        <div class="d-flex gap-2 align-items-center">
            <select class="form-select form-select-sm" id="scene-select" style="width: auto;">
                <option value="class">è¯¾ä¸­æ¼”ç¤º</option>
                <option value="practice">è¯¾åç»ƒä¹ </option>
            </select>
            <select class="form-select form-select-sm" id="mode-select" style="width: auto;">
                <option value="basic">åŸºç¡€æ­å»º</option>
                <option value="fault">æ•…éšœæ¨¡æ‹Ÿ</option>
            </select>
        </div>
    </div>

    <!-- æ•…éšœæ¨¡æ‹Ÿä¸“åŒº -->
    <div id="fault-panel" class="bg-light px-2 py-2 border-bottom d-none">
        <div class="d-flex align-items-center justify-content-between gap-2">
            <span style="font-size: 13px; white-space: nowrap;">æ¤å…¥æ•…éšœ:</span>
            <select class="form-select form-select-sm" id="fault-type">
                <option value="none">æ— æ•…éšœ (è‡ªç”±æ­å»ºè¯†åˆ«)</option>
                <option value="power_short">1. ç”µæºçŸ­è·¯</option>
                <option value="appliance_short">2. ç”¨ç”µå™¨çŸ­è·¯</option>
                <option value="wire_break">3. å¯¼çº¿æ–­è·¯</option>
                <option value="range_error">4. ç”µè¡¨é‡ç¨‹é€‰é”™</option>
            </select>
            <button style="width: 80px;" class="btn btn-sm btn-outline-danger" id="btn-trigger-fault">è§¦å‘</button>
        </div>
    </div>

    <!-- ç‰©ç†åŸç†å›¾ç¬¦å·åº“ -->
    <div id="palette-wrapper">
        <div class="component-palette" id="palette">
            <div class="palette-item" data-type="battery_1_5v">
                <svg viewBox="0 0 60 40">
                    <path d="M 0 20 L 25 20 M 25 10 L 25 30 M 35 15 L 35 25 M 35 20 L 60 20" stroke="#333" stroke-width="2"/>
                    <path d="M 35 15 L 35 25" stroke="#333" stroke-width="4"/>
                    <text x="12" y="12" font-size="12">+</text>
                    <text x="42" y="12" font-size="12">-</text>
                </svg>
                <span>ç”µæº(1.5V)</span>
            </div>
            <div class="palette-item" data-type="battery_3v">
                <svg viewBox="0 0 60 40">
                    <path d="M 0 20 L 25 20 M 25 10 L 25 30 M 35 15 L 35 25 M 35 20 L 60 20" stroke="#333" stroke-width="2"/>
                    <path d="M 35 15 L 35 25" stroke="#333" stroke-width="4"/>
                    <text x="12" y="12" font-size="12">+</text>
                    <text x="42" y="12" font-size="12">-</text>
                </svg>
                <span>ç”µæº(3V)</span>
            </div>
            <div class="palette-item" data-type="bulb">
                <svg viewBox="0 0 60 60">
                    <circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/>
                    <path d="M 19 19 L 41 41 M 19 41 L 41 19" stroke="#333" stroke-width="2"/>
                    <path d="M 5 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>
                </svg>
                <span>ç¯æ³¡</span>
            </div>
            <div class="palette-item" data-type="resistor">
                <svg viewBox="0 0 60 40">
                    <rect x="15" y="15" width="30" height="10" fill="#fff" stroke="#333" stroke-width="2"/>
                    <path d="M 5 20 L 15 20 M 45 20 L 55 20" stroke="#333" stroke-width="2"/>
                    <text x="30" y="12" font-size="10" text-anchor="middle">10Î©</text>
                </svg>
                <span>å®šå€¼ç”µé˜»</span>
            </div>
            <div class="palette-item" data-type="switch">
                <svg viewBox="0 0 60 40">
                    <path d="M 5 20 L 20 20 M 40 20 L 55 20" stroke="#333" stroke-width="2"/>
                    <circle cx="20" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/>
                    <circle cx="40" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/>
                    <line x1="20" y1="20" x2="38" y2="10" stroke="#333" stroke-width="2"/>
                </svg>
                <span>å¼€å…³</span>
            </div>
            <div class="palette-item" data-type="ammeter">
                <svg viewBox="0 0 60 60">
                    <circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/>
                    <text x="30" y="35" font-size="14" font-weight="bold" text-anchor="middle">A</text>
                    <path d="M 5 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>
                </svg>
                <span>ç”µæµè¡¨</span>
            </div>
            <div class="palette-item" data-type="voltmeter">
                <svg viewBox="0 0 60 60">
                    <circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/>
                    <text x="30" y="35" font-size="14" font-weight="bold" text-anchor="middle">V</text>
                    <path d="M 5 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/>
                </svg>
                <span>ç”µå‹è¡¨</span>
            </div>
        </div>
        <div id="palette-toggle" class="d-flex align-items-center justify-content-center gap-1 collapsed">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="transition: transform 0.3s ease;">
                <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
            <span>æ”¶èµ·å…ƒä»¶åº“</span>
        </div>
    </div>

    <!-- å®éªŒç”»å¸ƒ -->
    <div class="canvas-container" id="canvas-container">
        
        <!-- è¯¾åç»ƒä¹ ä»»åŠ¡æµ®çª— -->
        <div id="practice-panel" class="position-absolute top-0 end-0 m-3 p-3 bg-white border rounded shadow-sm d-none" style="z-index: 105; width: 320px;" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">
            
            <div class="d-flex justify-content-between align-items-center mb-0">
                <h6 class="text-primary m-0 fw-bold d-flex align-items-center gap-1">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"/></svg>
                    ç»ƒä¹ ä»»åŠ¡
                </h6>
                <div class="d-flex align-items-center gap-2">
                    <button class="btn btn-sm btn-outline-primary py-0 d-none d-md-inline-block" style="font-size: 12px;" onclick="startCreatePractice()">åˆ›å»ºç»ƒä¹ </button>
                    <span class="toggle-btn" onclick="togglePracticePanel()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </span>
                </div>
            </div>
            
            <div class="practice-content">
                <div id="practice-view-mode">
                    <div class="d-flex justify-content-between align-items-center mb-2 mt-2">
                        <button class="btn btn-sm btn-outline-primary py-0 d-md-none" style="font-size: 12px;" onclick="startCreatePractice()">åˆ›å»ºç»ƒä¹ </button>
                    </div>
                    
                    <select class="form-select form-select-sm mb-2" id="practice-select" onchange="loadSelectedPractice()">
                    </select>
                    
                    <div class="p-2 bg-light border rounded mb-2" style="max-height: 80px; overflow-y: auto;">
                        <p class="small text-muted m-0" id="practice-task-desc">ä»»åŠ¡ç›®æ ‡åŠ è½½ä¸­...</p>
                    </div>
                    
                    <!-- æ­¥éª¤å¼•å¯¼å±•ç¤ºåŒº -->
                    <div id="practice-hints-container" class="mb-3 text-start"></div>
                    
                    <div class="d-flex gap-2">
                        <button class="btn btn-sm btn-success flex-fill fw-bold shadow-sm" id="btn-submit-practice" onclick="verifyPractice()">æäº¤éªŒè¯</button>
                        <button class="btn btn-sm btn-outline-danger d-none" id="btn-delete-practice" onclick="deleteCurrentPractice()">åˆ é™¤</button>
                    </div>
                    <div id="practice-result" class="mt-2 small font-weight-bold text-center"></div>
                </div>

                <div id="practice-edit-mode" class="d-none">
                    <div class="d-flex align-items-center mb-2 mt-2">
                        <h6 class="text-primary m-0 fw-bold d-flex align-items-center gap-1">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                            åˆ›è®¾æ–°ç»ƒä¹ 
                        </h6>
                    </div>
                    <div class="p-2 bg-light border rounded mb-3">
                        <p class="small text-muted m-0">ç”»å¸ƒå·²æ¸…ç©ºã€‚è¯·æ‘†æ”¾æƒ³å‘ç»™å­¦ç”Ÿçš„**åˆå§‹å…ƒä»¶**ã€‚å®Œæˆåç‚¹å‡»ä¸‹æ–¹"ç¡®å®š"ä¿å­˜ã€‚</p>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn btn-sm btn-secondary flex-fill shadow-sm" onclick="cancelCreatePractice()">å–æ¶ˆ</button>
                        <button class="btn btn-sm btn-primary flex-fill fw-bold shadow-sm" onclick="showSaveTaskModal()">ç¡®å®šä¿å­˜</button>
                    </div>
                </div>
            </div>

        </div>

        <div class="canvas-wrapper" id="canvas-wrapper">
            <svg id="circuit-canvas" xmlns="http://www.w3.org/2000/svg">
                <!-- å¯¼çº¿å±‚ -->
                <g id="layer-wires"></g>
                <!-- å…ƒä»¶å±‚ -->
                <g id="layer-components"></g>
            </svg>
        </div>
        
        <!-- åˆ é™¤åƒåœ¾æ¡¶ -->
        <div id="trash-can" class="trash-can">
            <svg viewBox="0 0 24 24" width="28" height="28" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
        </div>
        
    </div>

    <!-- åº•éƒ¨æ§åˆ¶åŒº -->
    <div class="footer-area">
        <div id="status-display" class="status-box status-idle">ç­‰å¾…æ“ä½œ (æœªè¿æ¥ç”µæº)</div>
        <div class="d-flex justify-content-between gap-2">
            <button class="btn btn-secondary flex-fill" onclick="showGuide()">æ“ä½œæŒ‡å—</button>
            <button class="btn btn-danger flex-fill" onclick="resetCanvas()">é‡ç½®ç”»å¸ƒ</button>
            <button class="btn btn-primary flex-fill" id="btn-simulate" onclick="toggleSimulation()">å¯åŠ¨å®éªŒ</button>
        </div>
    </div>

    <!-- 3æ­¥æ“ä½œæŒ‡å— Modal -->
    <div class="modal fade" id="guideModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">ç®€å•ä¸‰æ­¥æ“ä½œæŒ‡å—</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                    <h6>ç¬¬ä¸€æ­¥ï¼šæ·»åŠ ä¸åˆ é™¤</h6>
                    <p class="text-muted small"><strong>é•¿æŒ‰æˆ–æ‹–æ‹½</strong>é¡¶éƒ¨å…ƒä»¶åº“ä¸­çš„å…ƒä»¶è‡³ç”»å¸ƒã€‚<br><strong>é•¿æŒ‰å…ƒä»¶æˆ–å¯¼çº¿</strong>ï¼Œå°†å…¶æ‹–å…¥å³ä¸‹è§’åƒåœ¾æ¡¶å³å¯åˆ é™¤ã€‚</p>
                    <hr>
                    <h6>ç¬¬äºŒæ­¥ï¼šè¿çº¿ä¸å¼€å…³</h6>
                    <p class="text-muted small"><strong>æŒ‰ä½</strong>å¼•è„šèŠ‚ç‚¹ï¼Œæ‹–åŠ¨è¿›è¡Œè¿çº¿ã€‚<br><strong>åŒå‡»</strong>å¼€å…³ç¬¦å·å¯ä»¥æ”¹å˜å…¶å¼€åˆçŠ¶æ€ã€‚</p>
                    <hr>
                    <h6>ç¬¬ä¸‰æ­¥ï¼šå¯åŠ¨ä¸è§‚å¯Ÿ</h6>
                    <p class="text-muted small">ç¡®ä¿ç”µè·¯é—­åˆåï¼Œç‚¹å‡»â€œå¯åŠ¨å®éªŒâ€ï¼Œè§‚å¯Ÿç¯æ³¡å‘å…‰åŠç”µè¡¨è¯»æ•°å˜åŒ–ã€‚</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary w-100" data-bs-dismiss="modal">æˆ‘çŸ¥é“äº†</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- æ•…éšœè¯Šæ–­ç»“æœ Modal -->
    <div class="modal fade" id="faultModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header bg-danger text-white">
                    <h5 class="modal-title" id="faultModalTitle">æ•…éšœè¯Šæ–­</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p class="text-danger fw-bold">ã€ç°è±¡ä¸åŸå› ã€‘</p>
                    <p id="faultModalDesc" class="text-muted small"></p>
                    <hr>
                    <p class="text-success fw-bold">ã€ä¿®æ”¹å»ºè®®ã€‘</p>
                    <p id="faultModalFix" class="text-muted small"></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">å…³é—­</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ä¿å­˜ç»ƒä¹  Modal -->
    <div class="modal fade" id="saveTaskModal" tabindex="-1" aria-hidden="true" style="z-index: 1060;">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">ä¿å­˜ä¸ºè‡ªå®šä¹‰ç»ƒä¹ </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label class="form-label">ç»ƒä¹ åç§°</label>
                        <input type="text" class="form-control" id="task-name-input" placeholder="ä¾‹å¦‚ï¼šæˆ‘çš„å¹¶è”ç”µè·¯æµ‹è¯•">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">ä»»åŠ¡è¦æ±‚ / æè¿°</label>
                        <textarea class="form-control" id="task-desc-input" rows="3" placeholder="æè¿°å­¦ç”Ÿéœ€è¦å®Œæˆçš„ç›®æ ‡..."></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">å–æ¶ˆ</button>
                    <button type="button" class="btn btn-primary" onclick="saveCurrentPractice()">ç¡®è®¤ä¿å­˜</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        const canvas = document.getElementById('circuit-canvas');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvasContainer = document.getElementById('canvas-container');
        const layerWires = document.getElementById('layer-wires');
        const layerComps = document.getElementById('layer-components');
        const statusDisplay = document.getElementById('status-display');
        const trashCan = document.getElementById('trash-can');
        
        let components = [];
        let wires = [];
        let compCounter = 0;
        let isSimulating = false;
        let conductingWireIds = new Set();
        
        let draggingComp = null;
        let isHoldingWire = false;
        let draggingWireId = null;
        let dragOffset = { x: 0, y: 0 };
        let isHoveringTrash = false;
        let wireTouchStartPt = null;

        let tempWire = null; 
        let allPinsCache = [];
        
        let canvasScale = 1;
        let canvasOffset = { x: 0, y: 0 };
        let isDraggingCanvas = false;
        let canvasDragStart = { x: 0, y: 0 };
        let canvasDragStartOffset = { x: 0, y: 0 };
        let canvasDragExceeded = false; // æ–°å¢é˜²æŠ–è¶Šç•Œæ ‡è¯†
        
        const gridSize = 20;

        // å…ƒä»¶å®šä¹‰
        const CompDefs = {
            battery_1_5v: {
                width: 60, height: 40, res: 0, type: 'source', voltage: 1.5,
                svg: `<rect width="60" height="40" fill="transparent"/><path d="M 0 20 L 25 20 M 25 10 L 25 30 M 35 15 L 35 25 M 35 20 L 60 20" stroke="#333" stroke-width="2"/><path d="M 35 15 L 35 25" stroke="#333" stroke-width="4"/><text x="12" y="12" font-size="12">+</text><text x="42" y="12" font-size="12">-</text><text class="meter-reading" x="30" y="40" font-size="10" text-anchor="middle" fill="#0d6efd">1.5V</text>`,
                pins: [{id: 'p1', x: 0, y: 20, type:'positive'}, {id: 'p2', x: 60, y: 20, type:'negative'}]
            },
            battery_3v: {
                width: 60, height: 40, res: 0, type: 'source', voltage: 3.0,
                svg: `<rect width="60" height="40" fill="transparent"/><path d="M 0 20 L 25 20 M 25 10 L 25 30 M 35 15 L 35 25 M 35 20 L 60 20" stroke="#333" stroke-width="2"/><path d="M 35 15 L 35 25" stroke="#333" stroke-width="4"/><text x="12" y="12" font-size="12">+</text><text x="42" y="12" font-size="12">-</text><text class="meter-reading" x="30" y="40" font-size="10" text-anchor="middle" fill="#0d6efd">3.0V</text>`,
                pins: [{id: 'p1', x: 0, y: 20, type:'positive'}, {id: 'p2', x: 60, y: 20, type:'negative'}]
            },
            bulb: {
                width: 60, height: 60, res: 10, type: 'load',
                svg: `<rect width="60" height="60" fill="transparent"/><circle class="bulb-glass" cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/><path d="M 19 19 L 41 41 M 19 41 L 41 19" stroke="#333" stroke-width="2" class="bulb-cross"/><path d="M 0 30 L 15 30 M 45 30 L 60 30" stroke="#333" stroke-width="2"/>`,
                pins: [{id: 'p1', x: 0, y: 30}, {id: 'p2', x: 60, y: 30}]
            },
            resistor: {
                width: 60, height: 40, res: 10, type: 'load',
                svg: `<rect width="60" height="40" fill="transparent"/><rect x="15" y="15" width="30" height="10" fill="#fff" stroke="#333" stroke-width="2"/><path d="M 0 20 L 15 20 M 45 20 L 60 20" stroke="#333" stroke-width="2"/><text x="30" y="10" font-size="10" text-anchor="middle">10Î©</text>`,
                pins: [{id: 'p1', x: 0, y: 20}, {id: 'p2', x: 60, y: 20}]
            },
            switch: {
                width: 60, height: 40, res: 0, type: 'switch',
                svg: `<rect width="60" height="40" fill="transparent"/><path d="M 0 20 L 15 20 M 45 20 L 60 20" stroke="#333" stroke-width="2"/><circle cx="15" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/><circle cx="45" cy="20" r="2" fill="#fff" stroke="#333" stroke-width="2"/><line class="switch-blade" x1="15" y1="20" x2="40" y2="10" stroke="#333" stroke-width="2"/>`,
                pins: [{id: 'p1', x: 0, y: 20}, {id: 'p2', x: 60, y: 20}]
            },
            ammeter: {
                width: 60, height: 60, res: 0, type: 'meter',
                svg: `<rect width="60" height="60" fill="transparent"/><circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/><text x="30" y="34" font-size="14" font-weight="bold" text-anchor="middle">A</text><path d="M 0 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/><text class="meter-reading" x="30" y="56" font-size="10" text-anchor="middle" fill="#6c757d">0.00A</text>`,
                pins: [{id: 'p1', x: 0, y: 30}, {id: 'p2', x: 60, y: 30}]
            },
            voltmeter: {
                width: 60, height: 60, res: 999999, type: 'meter',
                svg: `<rect width="60" height="60" fill="transparent"/><circle cx="30" cy="30" r="15" fill="#fff" stroke="#333" stroke-width="2"/><text x="30" y="34" font-size="14" font-weight="bold" text-anchor="middle">V</text><path d="M 0 30 L 15 30 M 45 30 L 55 30" stroke="#333" stroke-width="2"/><text class="meter-reading" x="30" y="56" font-size="10" text-anchor="middle" fill="#6c757d">0.00V</text>`,
                pins: [{id: 'p1', x: 0, y: 30}, {id: 'p2', x: 60, y: 30}]
            }
        };

        function updateCanvasTransform() {
            canvasWrapper.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${canvasScale})`;
            const gridSizeScaled = gridSize * canvasScale;
            canvasContainer.style.backgroundSize = `${gridSizeScaled}px ${gridSizeScaled}px`;
            canvasContainer.style.backgroundPosition = `${canvasOffset.x}px ${canvasOffset.y}px`;
        }
        

        // å…ƒä»¶åº“é¢æ¿æ”¶èµ·/å±•å¼€
        let paletteOpen = true;
        const paletteToggle = document.getElementById('palette-toggle');
        paletteToggle.addEventListener('click', () => {
            paletteOpen = !paletteOpen;
            document.getElementById('palette').style.display = paletteOpen ? 'flex' : 'none';
            if(paletteOpen) {
                paletteToggle.classList.add('collapsed');
                paletteToggle.querySelector('span').textContent = 'æ”¶èµ·å…ƒä»¶åº“';
            } else {
                paletteToggle.classList.remove('collapsed');
                paletteToggle.querySelector('span').textContent = 'å±•å¼€å…ƒä»¶åº“';
            }
        });

        // ================= ç»ƒä¹ ä»»åŠ¡ç®¡ç† =================
        const STORE_KEY = 'circuit_custom_tasks';
        let allPractices = [];
        let lastSelectedPracticeId = null;

        function initPractices() {
            const defaults = [
                {
                    id: 'default_1',
                    name: 'åŸºç¡€ä¸²è”ç”µè·¯',
                    description: 'è¯·ä½¿ç”¨å·²æä¾›çš„ç”µæºã€å¼€å…³å’Œç¯æ³¡ï¼Œæ­å»ºä¸€ä¸ªåŸºæœ¬çš„é—­åˆä¸²è”ç”µè·¯ã€‚å®Œæˆåå¯åŠ¨å®éªŒå¹¶ç‚¹äº®ç¯æ³¡ï¼',
                    steps: [
                        "1. é•¿æŒ‰å…ƒä»¶çš„çº¢è‰²å¼•è„šå¹¶æ‹–åŠ¨ï¼Œå°†ç”µæºæ­£æä¸å¼€å…³å·¦ä¾§è¿æ¥ã€‚",
                        "2. åŒæ ·çš„æ–¹æ³•ï¼Œå°†å¼€å…³å³ä¾§ä¸ç¯æ³¡ä¸€ç«¯è¿æ¥ã€‚",
                        "3. å°†ç¯æ³¡å¦ä¸€ç«¯ä¸ç”µæºè´Ÿæï¼ˆè“è‰²å¼•è„šï¼‰è¿æ¥ã€‚",
                        "4. ç‚¹å‡»åº•éƒ¨çš„â€œå¯åŠ¨å®éªŒâ€ï¼Œç„¶ååŒå‡»å¼€å…³å°†å…¶é—­åˆï¼Œè§‚å¯Ÿç¯æ³¡ã€‚"
                    ],
                    components: [
                        { id: 'comp_1', type: 'battery_3v', x: 100, y: 180, isClosed: false },
                        { id: 'comp_2', type: 'switch', x: 280, y: 180, isClosed: false },
                        { id: 'comp_3', type: 'bulb', x: 200, y: 110, isClosed: false }
                    ],
                    wires: [],
                    isCustom: false
                },
                {
                    id: 'default_2',
                    name: 'å¹¶è”ç”µè·¯æŒ‘æˆ˜',
                    description: 'è¯·ä½¿ç”¨æä¾›çš„ç”µæºã€ä¸¤ä¸ªç¯æ³¡ã€ä¸¤ä¸ªå¼€å…³ã€‚ä½¿ä¸¤ä¸ªå¼€å…³åˆ†åˆ«ç‹¬ç«‹æ§åˆ¶ä¸¤ä¸ªç¯æ³¡ï¼ˆå¹¶è”å…³ç³»ï¼‰ã€‚',
                    steps: [
                        "1. å°†ç”µæºæ­£æåˆ†åˆ«è¿æ¥åˆ°ä¸¤ä¸ªå¼€å…³çš„ä¸€ç«¯ï¼ˆå½¢æˆåˆ†æµç‚¹ï¼‰ã€‚",
                        "2. å°†ä¸¤ä¸ªå¼€å…³çš„å¦ä¸€ç«¯ï¼Œåˆ†åˆ«è¿æ¥åˆ°ä¸¤ä¸ªç¯æ³¡çš„ä¸€ç«¯ã€‚",
                        "3. å°†ä¸¤ä¸ªç¯æ³¡çš„å¦ä¸€ç«¯ï¼Œå…¨éƒ¨è¿æ¥å›ç”µæºçš„è´Ÿæï¼ˆæ±‡åˆï¼‰ã€‚",
                        "4. å¯åŠ¨å®éªŒåï¼Œåˆ†åˆ«åŒå‡»é—­åˆä¸¤ä¸ªå¼€å…³ï¼ŒéªŒè¯æ˜¯å¦èƒ½ç‹¬ç«‹æ§åˆ¶ç¯æ³¡ã€‚"
                    ],
                    components: [
                        { id: 'comp_1', type: 'battery_3v', x: 80, y: 180, isClosed: false },
                        { id: 'comp_2', type: 'bulb', x: 280, y: 170, isClosed: false },
                        { id: 'comp_3', type: 'bulb', x: 280, y: 290, isClosed: false },
                        { id: 'comp_4', type: 'switch', x: 180, y: 180, isClosed: false },
                        { id: 'comp_5', type: 'switch', x: 180, y: 300, isClosed: false }
                    ],
                    wires: [],
                    isCustom: false
                }
            ];

            let customs = [];
            try {
                const saved = localStorage.getItem(STORE_KEY);
                if(saved) customs = JSON.parse(saved);
            } catch(e) {}

            allPractices = [...defaults, ...customs];
            
            const select = document.getElementById('practice-select');
            select.innerHTML = '';
            allPractices.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.innerText = (p.isCustom ? '[è‡ªå®šä¹‰] ' : '') + p.name;
                select.appendChild(opt);
            });
        }

        function loadSelectedPractice() {
            const id = document.getElementById('practice-select').value;
            const task = allPractices.find(p => p.id === id);
            if(!task) return;

            document.getElementById('practice-task-desc').innerText = task.description;
            document.getElementById('practice-result').innerText = '';
            
            let hintsHTML = '';
            if (task.steps && task.steps.length > 0) {
                hintsHTML = `
                <button class="btn btn-sm btn-link p-0 text-decoration-none" onclick="document.getElementById('hints-list').classList.toggle('d-none')">ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹æ­¥éª¤å¼•å¯¼</button>
                <ul id="hints-list" class="d-none small text-muted mt-1 ps-3 mb-1">
                    ${task.steps.map(s => `<li>${s}</li>`).join('')}
                </ul>`;
            }
            document.getElementById('practice-hints-container').innerHTML = hintsHTML;
            
            const delBtn = document.getElementById('btn-delete-practice');
            if(task.isCustom) delBtn.classList.remove('d-none');
            else delBtn.classList.add('d-none');

            resetSimulation();
            components = task.components.map(c => {
                let cType = c.type;
                if (cType === 'battery') cType = 'battery_3v'; // å…¼å®¹æ—§ç‰ˆæœ¬ç¼“å­˜
                return {
                    id: c.id, type: cType, x: c.x, y: c.y, def: CompDefs[cType], isClosed: c.isClosed || false
                };
            });
            wires = task.wires.map(w => ({...w}));
            
            let maxId = 0;
            components.forEach(c => {
                const num = parseInt(c.id.split('_')[1]);
                if(!isNaN(num) && num > maxId) maxId = num;
            });
            compCounter = maxId;

            canvasOffset = {x: 0, y: 0};
            canvasScale = 1;
            updateCanvasTransform();
            
            renderComponents();
            renderWires();
            setStatus('idle', 'ç›®æ ‡ä»»åŠ¡æ¨¡å¼ï¼šè¯·æ ¹æ®æç¤ºè¿æ¥ç”µè·¯ã€‚');
        }

        window.startCreatePractice = function() {
            lastSelectedPracticeId = document.getElementById('practice-select').value;
            document.getElementById('practice-view-mode').classList.add('d-none');
            document.getElementById('practice-edit-mode').classList.remove('d-none');
            resetCanvas(true);
            setStatus('idle', 'åˆ›è®¾æ–°ç»ƒä¹ ï¼šè¯·åœ¨ç”»å¸ƒä¸Šæ‘†æ”¾æ‰€éœ€å…ƒä»¶å’Œè¿çº¿...');
        };

        window.cancelCreatePractice = function() {
            document.getElementById('practice-edit-mode').classList.add('d-none');
            document.getElementById('practice-view-mode').classList.remove('d-none');
            if (lastSelectedPracticeId) {
                document.getElementById('practice-select').value = lastSelectedPracticeId;
                loadSelectedPractice();
            }
        };

        window.showSaveTaskModal = function() {
            new bootstrap.Modal(document.getElementById('saveTaskModal')).show();
        };

        window.saveCurrentPractice = function() {
            const name = document.getElementById('task-name-input').value.trim();
            const desc = document.getElementById('task-desc-input').value.trim();
            if(!name) return alert('è¯·è¾“å…¥ç»ƒä¹ åç§°');

            const savedComps = components.map(c => ({ id: c.id, type: c.type, x: c.x, y: c.y, isClosed: c.isClosed }));
            const savedWires = wires.map(w => ({ id: w.id, p1: w.p1, p2: w.p2 }));

            const newTask = {
                id: 'custom_' + Date.now(), name: name, description: desc || 'æ— è¯¦ç»†è¦æ±‚', steps: [],
                components: savedComps, wires: savedWires, isCustom: true
            };

            let customs = [];
            try {
                const saved = localStorage.getItem(STORE_KEY);
                if(saved) customs = JSON.parse(saved);
            } catch(e) {}

            customs.push(newTask);
            localStorage.setItem(STORE_KEY, JSON.stringify(customs));

            bootstrap.Modal.getInstance(document.getElementById('saveTaskModal')).hide();
            document.getElementById('task-name-input').value = '';
            document.getElementById('task-desc-input').value = '';

            document.getElementById('practice-edit-mode').classList.add('d-none');
            document.getElementById('practice-view-mode').classList.remove('d-none');

            initPractices();
            document.getElementById('practice-select').value = newTask.id;
            loadSelectedPractice();
            alert('æˆåŠŸä¿å­˜ä¸ºè‡ªå®šä¹‰ç»ƒä¹ ï¼');
        };

        window.deleteCurrentPractice = function() {
            const id = document.getElementById('practice-select').value;
            const task = allPractices.find(p => p.id === id);
            if(!task || !task.isCustom) return;

            if(!confirm(`ç¡®å®šè¦åˆ é™¤è‡ªå®šä¹‰ç»ƒä¹  "${task.name}" å—ï¼Ÿ`)) return;

            let customs = [];
            try {
                const saved = localStorage.getItem(STORE_KEY);
                if(saved) customs = JSON.parse(saved);
            } catch(e) {}

            customs = customs.filter(c => c.id !== id);
            localStorage.setItem(STORE_KEY, JSON.stringify(customs));

            initPractices();
            loadSelectedPractice();
        };

        window.togglePracticePanel = function() {
            const panel = document.getElementById('practice-panel');
            panel.classList.toggle('collapsed');
        };

        function isMobileDevice() {
            return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        window.verifyPractice = function() {
            const resultDiv = document.getElementById('practice-result');
            
            if(!isSimulating) {
                resultDiv.innerHTML = '<span class="text-warning">è¯·å…ˆç‚¹å‡»åº•éƒ¨â€œå¯åŠ¨å®éªŒâ€è®©ç”µè·¯è¿è¡Œï¼</span>';
                return;
            }

            if (statusDisplay.classList.contains('status-error') || statusDisplay.classList.contains('status-idle')) {
                resultDiv.innerHTML = '<span class="text-danger">ä»»åŠ¡å¤±è´¥ï¼šç”µè·¯å­˜åœ¨æ•…éšœã€çŸ­è·¯æˆ–æœªèƒ½è¿é€šã€‚</span>';
                return;
            }
            
            const bulbs = components.filter(c => c.type === 'bulb');
            if(bulbs.length > 0) {
                let allLit = true;
                bulbs.forEach(b => {
                    const compGroup = document.querySelector(`g[data-id="${b.id}"]`);
                    if(compGroup) {
                        const glass = compGroup.querySelector('.bulb-glass');
                        if(!glass || !glass.classList.contains('active')) allLit = false;
                    }
                });

                if(allLit) resultDiv.innerHTML = '<span class="text-success">ğŸ‰ æ­å–œï¼ç”µè·¯è¿é€šæ­£ç¡®ï¼Œç¯æ³¡å·²å…¨éƒ¨ç‚¹äº®ï¼</span>';
                else resultDiv.innerHTML = '<span class="text-danger">ä»»åŠ¡å¤±è´¥ï¼šéƒ¨åˆ†ç¯æ³¡æœªèƒ½å‘å…‰ï¼Œè¯·æ£€æŸ¥æ”¯è·¯è¿çº¿ã€‚</span>';
            } else {
                resultDiv.innerHTML = '<span class="text-success">ğŸ‰ æ­å–œï¼ä»»åŠ¡éªŒè¯é€šè¿‡ï¼ç”µè·¯æ— å¼‚å¸¸ã€‚</span>';
            }
        };

        // äº‹ä»¶ä¾¦å¬å™¨
        document.addEventListener('DOMContentLoaded', () => {
            initPractices();

            document.getElementById('scene-select').addEventListener('change', (e) => {
                const val = e.target.value;
                const practicePanel = document.getElementById('practice-panel');
                const faultPanel = document.getElementById('fault-panel');
                const modeSelect = document.getElementById('mode-select');
                
                document.getElementById('practice-edit-mode').classList.add('d-none');
                document.getElementById('practice-view-mode').classList.remove('d-none');

                if(val === 'practice') {
                    practicePanel.classList.remove('d-none');
                    if(isMobileDevice()) practicePanel.classList.add('collapsed');
                    else practicePanel.classList.remove('collapsed');
                    modeSelect.value = 'basic';
                    faultPanel.classList.add('d-none');
                    document.getElementById('fault-type').value = 'none';
                    initPractices(); 
                    loadSelectedPractice(); 
                } else {
                    practicePanel.classList.add('d-none');
                    resetCanvas(true);
                    setStatus('idle', 'ç­‰å¾…æ“ä½œï¼šå¯è‡ªç”±æ­å»ºç”µè·¯ã€‚');
                }
            });

            document.getElementById('mode-select').addEventListener('change', (e) => {
                const faultPanel = document.getElementById('fault-panel');
                if(e.target.value === 'fault') {
                    faultPanel.classList.remove('d-none');
                    document.getElementById('scene-select').value = 'class'; // switch to class mode automatically
                    document.getElementById('practice-panel').classList.add('d-none');
                } else {
                    faultPanel.classList.add('d-none');
                    document.getElementById('fault-type').value = 'none';
                }
                resetSimulation();
            });

            document.getElementById('fault-type').addEventListener('change', (e) => {
                if (e.target.value !== 'none') {
                    loadPresetFault(e.target.value);
                } else {
                    resetCanvas(true);
                }
            });

            document.getElementById('btn-trigger-fault').addEventListener('click', triggerFaultDiagnosis);

            let spaceKey = false;

            // ç”»å¸ƒäº¤äº’æ ¸å¿ƒé€»è¾‘ï¼ˆå·²ä¿®å¤é¼ æ ‡åŠè§¦æ‘¸å±é˜²æŠ–è·³è·ƒã€ç¼©æ”¾åç§»é—®é¢˜ï¼Œå¹¶è§£é”è¿è¡ŒæœŸè§†è§’æ§åˆ¶ï¼‰
            canvasContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const rect = canvasContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldX = (mouseX - canvasOffset.x) / canvasScale;
                const worldY = (mouseY - canvasOffset.y) / canvasScale;
                canvasScale = Math.max(0.3, Math.min(3, canvasScale * delta));
                canvasOffset.x = mouseX - worldX * canvasScale;
                canvasOffset.y = mouseY - worldY * canvasScale;
                updateCanvasTransform();
            }, {passive: false});

            canvasContainer.addEventListener('mousedown', (e) => {
                if(e.target === canvasContainer || e.target === canvas || e.target === canvasWrapper) {
                    if(e.button === 1 || (e.button === 0 && spaceKey)) {
                        e.preventDefault();
                        isDraggingCanvas = true;
                        canvasDragExceeded = false;
                        canvasDragStart = { x: e.clientX, y: e.clientY };
                        canvasDragStartOffset = { ...canvasOffset };
                    }
                }
            });

            document.addEventListener('mousemove', (e) => {
                if(isDraggingCanvas) {
                    if (!canvasDragExceeded) {
                        const dist = Math.hypot(e.clientX - canvasDragStart.x, e.clientY - canvasDragStart.y);
                        if (dist > 10) { 
                            canvasDragExceeded = true;
                            canvasDragStart = { x: e.clientX, y: e.clientY };
                            canvasDragStartOffset = { ...canvasOffset };
                        }
                    }
                    if (canvasDragExceeded) {
                        e.preventDefault();
                        canvasOffset.x = canvasDragStartOffset.x + (e.clientX - canvasDragStart.x);
                        canvasOffset.y = canvasDragStartOffset.y + (e.clientY - canvasDragStart.y);
                        updateCanvasTransform();
                    }
                }
            });

            document.addEventListener('mouseup', (e) => {
                if(e.button === 1 || e.button === 0) isDraggingCanvas = false;
            });

            document.addEventListener('keydown', (e) => {
                if(e.code === 'Space') {
                    spaceKey = true;
                    canvasContainer.style.cursor = 'grab';
                }
            });
            document.addEventListener('keyup', (e) => {
                if(e.code === 'Space') {
                    spaceKey = false;
                    canvasContainer.style.cursor = '';
                    isDraggingCanvas = false;
                }
            });

            let touchStartDistance = 0, touchStartScale = 1, touchStartOffset = { x: 0, y: 0 }, lastTouchCenter = { x: 0, y: 0 };

            canvasContainer.addEventListener('touchstart', (e) => {
                if(e.touches.length >= 2) {
                    e.preventDefault();
                    isDraggingCanvas = false; // å–æ¶ˆå•æŒ‡æ‹–æ‹½çŠ¶æ€
                    const touch1 = e.touches[0], touch2 = e.touches[1];
                    touchStartDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                    touchStartScale = canvasScale;
                    touchStartOffset = { ...canvasOffset };
                    lastTouchCenter = { x: (touch1.clientX + touch2.clientX) / 2, y: (touch1.clientY + touch2.clientY) / 2 };
                } else if(e.touches.length === 1 && !draggingComp && !tempWire && !isHoldingWire) {
                    isDraggingCanvas = true;
                    canvasDragExceeded = false;
                    const touch = e.touches[0];
                    canvasDragStart = { x: touch.clientX, y: touch.clientY };
                    canvasDragStartOffset = { ...canvasOffset };
                }
            }, {passive: false});

            canvasContainer.addEventListener('touchmove', (e) => {
                if(e.touches.length >= 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0], touch2 = e.touches[1];
                    const distance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                    if (touchStartDistance > 0) {
                        const scale = touchStartScale * (distance / touchStartDistance);
                        canvasScale = Math.max(0.3, Math.min(3, scale));
                        const center = { x: (touch1.clientX + touch2.clientX) / 2, y: (touch1.clientY + touch2.clientY) / 2 };
                        const rect = canvasContainer.getBoundingClientRect();
                        const worldX = (lastTouchCenter.x - rect.left - touchStartOffset.x) / touchStartScale;
                        const worldY = (lastTouchCenter.y - rect.top - touchStartOffset.y) / touchStartScale;
                        canvasOffset.x = center.x - rect.left - worldX * canvasScale;
                        canvasOffset.y = center.y - rect.top - worldY * canvasScale;
                        updateCanvasTransform();
                    }
                } else if(isDraggingCanvas && e.touches.length === 1) {
                    const touch = e.touches[0];
                    if (!canvasDragExceeded) {
                        const dist = Math.hypot(touch.clientX - canvasDragStart.x, touch.clientY - canvasDragStart.y);
                        if (dist > 10) { 
                            canvasDragExceeded = true;
                            // é‡ç½®å‚è€ƒç‚¹ä½ï¼Œä¿è¯å¹³ç§»æ— è·³å˜åç§»
                            canvasDragStart = { x: touch.clientX, y: touch.clientY };
                            canvasDragStartOffset = { ...canvasOffset };
                        }
                    }
                    if (canvasDragExceeded) {
                        e.preventDefault();
                        canvasOffset.x = canvasDragStartOffset.x + (touch.clientX - canvasDragStart.x);
                        canvasOffset.y = canvasDragStartOffset.y + (touch.clientY - canvasDragStart.y);
                        updateCanvasTransform();
                    }
                }
            }, {passive: false});

            canvasContainer.addEventListener('touchend', (e) => {
                if (e.touches.length === 0) {
                    isDraggingCanvas = false;
                } else if (e.touches.length === 1 && !draggingComp && !tempWire && !isHoldingWire) {
                    // å½“ä»åŒæŒ‡ç¼©æ”¾å˜ä¸ºå•æŒ‡ä¿ç•™æ—¶ï¼Œç›´æ¥é¡ºæ»‘æ¥ç®¡ä¸ºæ‹–åŠ¨ç”»å¸ƒï¼Œä¸å†å‡ºç°ä½ç½®é—ªè·³
                    isDraggingCanvas = true;
                    canvasDragExceeded = true; 
                    const touch = e.touches[0];
                    canvasDragStart = { x: touch.clientX, y: touch.clientY };
                    canvasDragStartOffset = { ...canvasOffset };
                }
            });

            canvas.addEventListener('touchstart', handleDragStart, {passive: false});
            document.addEventListener('touchmove', handleDragMove, {passive: false});
            document.addEventListener('touchend', handleDragEnd);
            canvas.addEventListener('mousedown', handleDragStart);
            
            initPaletteDrag();
            updateCanvasTransform();
        });

        function showGuide() { new bootstrap.Modal(document.getElementById('guideModal')).show(); }

        // è½½å…¥æ•…éšœé¢„è®¾ç”µè·¯
        function loadPresetFault(type) {
            resetCanvas(true);
            isSimulating = false;
            document.getElementById('btn-simulate').innerText = "å¯åŠ¨å®éªŒ";
            document.getElementById('btn-simulate').classList.replace('btn-warning', 'btn-primary');
            
            if(type === 'power_short') {
                components = [
                    { id: 'comp_1', type: 'battery_3v', x: 120, y: 120, def: CompDefs.battery_3v, isClosed: false },
                    { id: 'comp_2', type: 'switch', x: 280, y: 180, def: CompDefs.switch, isClosed: true }
                ];
                wires = [
                    { id: 'w_1', p1: 'comp_1_p1', p2: 'comp_2_p1' },
                    { id: 'w_2', p1: 'comp_1_p2', p2: 'comp_2_p2' }
                ];
                compCounter = 2;
            } else if(type === 'appliance_short') {
                components = [
                    { id: 'comp_1', type: 'battery_3v', x: 100, y: 160, def: CompDefs.battery_3v, isClosed: false },
                    { id: 'comp_2', type: 'switch', x: 280, y: 120, def: CompDefs.switch, isClosed: true },
                    { id: 'comp_3', type: 'bulb', x: 200, y: 230, def: CompDefs.bulb, isClosed: false }
                ];
                wires = [
                    { id: 'w_1', p1: 'comp_1_p1', p2: 'comp_2_p1' },
                    { id: 'w_2', p1: 'comp_2_p2', p2: 'comp_3_p2' },
                    { id: 'w_3', p1: 'comp_3_p1', p2: 'comp_1_p2' },
                    { id: 'w_4', p1: 'comp_3_p1', p2: 'comp_3_p2' }
                ];
                compCounter = 3;
            } else if(type === 'wire_break') {
                components = [
                    { id: 'comp_1', type: 'battery_3v', x: 100, y: 160, def: CompDefs.battery_3v, isClosed: false },
                    { id: 'comp_2', type: 'switch', x: 280, y: 120, def: CompDefs.switch, isClosed: true },
                    { id: 'comp_3', type: 'bulb', x: 200, y: 230, def: CompDefs.bulb, isClosed: false }
                ];
                wires = [
                    { id: 'w_1', p1: 'comp_1_p1', p2: 'comp_2_p1' },
                    { id: 'w_3', p1: 'comp_3_p1', p2: 'comp_1_p2' }
                ];
                compCounter = 3;
            } else if(type === 'range_error') {
                components = [
                    { id: 'comp_1', type: 'battery_3v', x: 100, y: 160, def: CompDefs.battery_3v, isClosed: false },
                    { id: 'comp_2', type: 'switch', x: 280, y: 120, def: CompDefs.switch, isClosed: true },
                    { id: 'comp_3', type: 'ammeter', x: 200, y: 230, def: CompDefs.ammeter, isClosed: false }
                ];
                wires = [
                    { id: 'w_1', p1: 'comp_1_p1', p2: 'comp_2_p1' },
                    { id: 'w_2', p1: 'comp_2_p2', p2: 'comp_3_p2' },
                    { id: 'w_3', p1: 'comp_3_p1', p2: 'comp_1_p2' }
                ];
                compCounter = 3;
            }
            canvasOffset = {x: 40, y: 40}; // Center it slightly
            updateCanvasTransform();
            renderComponents();
            renderWires();
            setStatus('idle', 'å·²è½½å…¥æ•…éšœç”µè·¯ã€‚ç‚¹å‡»å³ä¸Šè§’ã€è§¦å‘ã€‘æŸ¥çœ‹åŸå› ã€‚');
        }

        function triggerFaultDiagnosis() {
            const type = document.getElementById('fault-type').value;
            if(type === 'none') {
                toggleSimulation();
                return;
            }
            
            isSimulating = true;
            document.getElementById('btn-simulate').innerText = "åœæ­¢å®éªŒ";
            document.getElementById('btn-simulate').classList.replace('btn-primary', 'btn-warning');
            
            let title = "", desc = "", fix = "";
            switch(type) {
                case 'power_short':
                    title = "ğŸ’¥ ç”µæºçŸ­è·¯";
                    desc = "ç”µæµæœªç»è¿‡ä»»ä½•ç”¨ç”µå™¨ï¼Œç›´æ¥ä»ç”µæºæ­£ææµå›äº†è´Ÿæã€‚è¿™ä¼šäº§ç”Ÿæå¤§çš„ç”µæµï¼Œç¬é—´çƒ§æ¯ç”µæºå’Œå¯¼çº¿ï¼";
                    fix = "ç¡®ä¿ç”µè·¯ä¸­è‡³å°‘ä¸²è”ä¸€ä¸ªç”¨ç”µå™¨ï¼ˆå¦‚ç¯æ³¡æˆ–å®šå€¼ç”µé˜»ï¼‰ã€‚è¯·æ–­å¼€å¼€å…³ï¼Œé•¿æŒ‰å¹¶æ‹–åŠ¨ç›´æ¥è¿æ¥ç”µæºä¸¤æçš„å¯¼çº¿åˆ°åƒåœ¾æ¡¶ï¼Œç„¶åæ¥å…¥ç”¨ç”µå™¨ã€‚";
                    break;
                case 'appliance_short':
                    title = "âš ï¸ ç”¨ç”µå™¨çŸ­è·¯";
                    desc = "æœ‰ä¸€æ ¹å¯¼çº¿ç›´æ¥å¹¶è”åœ¨äº†ç¯æ³¡ä¸¤ç«¯ã€‚ç”±äºå¯¼çº¿ç”µé˜»å‡ ä¹ä¸ºé›¶ï¼Œç”µæµä¼šâ€œèµ°æ·å¾„â€å…¨éƒ¨é€šè¿‡å¯¼çº¿ï¼Œå¯¼è‡´ç¯æ³¡ä¸äº®ï¼ŒåŒæ—¶è¿™ä¹Ÿæ˜¯ä¸€ç§çŸ­è·¯è¡Œä¸ºã€‚";
                    fix = "æ‰¾å‡ºå¹¶æ‹†é™¤ä¸ç”¨ç”µå™¨ä¸¤ç«¯ç›´æ¥ç›¸è¿çš„â€œæ·å¾„â€å¯¼çº¿ã€‚é•¿æŒ‰è¯¥å¯¼çº¿æ‹–å…¥åƒåœ¾æ¡¶å³å¯ã€‚";
                    break;
                case 'wire_break':
                    title = "ğŸ”Œ å¯¼çº¿æ–­è·¯";
                    desc = "ç”µè·¯å­˜åœ¨æ–­å¼€çš„åœ°æ–¹ï¼ˆå¦‚ç¼ºå¤±å¯¼çº¿æˆ–æ¥è§¦ä¸è‰¯ï¼‰ï¼Œç”µæµæ— æ³•å½¢æˆé—­åˆå›è·¯ï¼Œå› æ­¤ç”¨ç”µå™¨æ— æ³•å·¥ä½œã€‚";
                    fix = "ä»”ç»†æ£€æŸ¥å„å…ƒä»¶ä¹‹é—´çš„è¿æ¥ï¼Œæ‹–æ‹½å¼•è„šè¡¥å……ç¼ºå¤±çš„å¯¼çº¿ï¼Œç¡®ä¿ç”µè·¯æ˜¯ä¸€ä¸ªé¦–å°¾ç›¸è¿å®Œæ•´çš„ç¯ã€‚";
                    break;
                case 'range_error':
                    title = "âš¡ ç”µè¡¨ä½¿ç”¨é”™è¯¯ (é‡ç¨‹æˆ–è¿æ³•)";
                    desc = "å›¾ä¸­å°†å†…é˜»æå°çš„ç”µæµè¡¨ç›´æ¥æ¥åœ¨äº†ç”µæºä¸¤ç«¯ï¼ˆæ²¡æœ‰ä¸²è”å…¶ä»–ç”¨ç”µå™¨ï¼‰ï¼Œæˆ–è€…å°†ç”µå‹è¡¨é”™è¯¯åœ°ä¸²è”åœ¨äº†å¹²è·¯ä¸­ã€‚";
                    fix = "ç”µæµè¡¨å¿…é¡»ä¸è¢«æµ‹ç”¨ç”µå™¨ã€ä¸²è”ã€‘ï¼Œç”µå‹è¡¨å¿…é¡»ä¸è¢«æµ‹ç”¨ç”µå™¨ã€å¹¶è”ã€‘ã€‚å¹¶ä¸”é¢„ä¼°è¯»æ•°ä¸èƒ½è¶…è¿‡ä»ªè¡¨çš„æœ€å¤§é‡ç¨‹ã€‚";
                    break;
            }
            
            document.getElementById('faultModalTitle').innerText = title;
            document.getElementById('faultModalDesc').innerText = desc;
            document.getElementById('faultModalFix').innerText = fix;
            new bootstrap.Modal(document.getElementById('faultModal')).show();
            
            updateSimulation();
        }

        function initPaletteDrag() {
            const paletteItems = document.querySelectorAll('.palette-item');
            paletteItems.forEach(item => {
                let holdTimer = null, isHolding = false;
                const startPaletteDrag = (pt, type) => {
                    if(isSimulating) return alert('è¯·å…ˆåœæ­¢å®éªŒå†ä¿®æ”¹ç”µè·¯');
                    const def = CompDefs[type];
                    const world = screenToWorld(pt.x, pt.y);
                    
                    let pinOffsetX = def.pins[0].x;
                    let pinOffsetY = def.pins[0].y;
                    const comp = {
                        id: 'comp_' + (++compCounter),
                        type: type,
                        x: Math.round((world.x - def.width / 2 + pinOffsetX) / gridSize) * gridSize - pinOffsetX,
                        y: Math.round((world.y - def.height / 2 + pinOffsetY) / gridSize) * gridSize - pinOffsetY,
                        def: def,
                        isClosed: false
                    };
                    components.push(comp);
                    draggingComp = comp;
                    dragOffset = { x: def.width / 2, y: def.height / 2 };
                    trashCan.classList.add('visible');
                    renderComponents();
                };

                item.addEventListener('touchstart', (e) => {
                    if(isSimulating) return;
                    const pt = getEventPoint(e);
                    isHolding = false;
                    holdTimer = setTimeout(() => {
                        isHolding = true;
                        startPaletteDrag(pt, item.getAttribute('data-type'));
                    }, 200); 
                }, {passive: true});

                item.addEventListener('touchmove', (e) => {
                    if (!isHolding && holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
                    if (isHolding) { e.preventDefault(); handleDragMove(e); }
                }, {passive: false});

                const cancelTouch = (e) => {
                    if (holdTimer) clearTimeout(holdTimer);
                    if (isHolding) { handleDragEnd(e); isHolding = false; }
                };
                item.addEventListener('touchend', cancelTouch);
                item.addEventListener('touchcancel', cancelTouch);

                item.addEventListener('mousedown', (e) => {
                    if(isSimulating) return alert('è¯·å…ˆåœæ­¢å®éªŒå†ä¿®æ”¹ç”µè·¯');
                    e.preventDefault();
                    startPaletteDrag(getEventPoint(e), item.getAttribute('data-type'));
                });
            });
        }

        function renderComponents() {
            layerComps.innerHTML = '';
            components.forEach(comp => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'component-group');
                g.setAttribute('transform', `translate(${comp.x}, ${comp.y})`);
                g.setAttribute('data-id', comp.id);
                
                let svgContent = comp.def.svg;
                if(comp.type === 'switch' && comp.isClosed) {
                    svgContent = svgContent.replace('y2="10"', 'y2="20"');
                }
                g.innerHTML = svgContent;

                if(comp.type === 'switch') {
                    g.addEventListener('dblclick', (e) => toggleSwitch(comp.id, e));
                    let touchStartTime = 0;
                    g.addEventListener('touchstart', () => touchStartTime = Date.now());
                    g.addEventListener('touchend', (e) => {
                        if(Date.now() - touchStartTime < 250 && !draggingComp) toggleSwitch(comp.id, e);
                    });
                }

                comp.def.pins.forEach(pin => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    const pinId = `${comp.id}_${pin.id}`;
                    circle.setAttribute('class', `terminal ${pin.type === 'negative' ? 'negative' : ''}`);
                    circle.setAttribute('cx', pin.x);
                    circle.setAttribute('cy', pin.y);
                    circle.setAttribute('r', 5);
                    circle.setAttribute('data-pinid', pinId);
                    circle.setAttribute('data-compid', comp.id);
                    g.appendChild(circle);
                });
                
                layerComps.appendChild(g);
            });
        }

        function toggleSwitch(id, e) {
            if(e) e.stopPropagation();
            const comp = components.find(c => c.id === id);
            if(comp) {
                comp.isClosed = !comp.isClosed;
                renderComponents();
                if(isSimulating) updateSimulation();
            }
        }

        function getPinCoords(pinId) {
            const lastIndex = pinId.lastIndexOf('_');
            const actualCompId = pinId.substring(0, lastIndex);
            const actualPinId = pinId.substring(lastIndex + 1);
            const c = components.find(x => x.id === actualCompId);
            if(!c) return {x:0, y:0};
            const p = c.def.pins.find(x => x.id === actualPinId);
            return { x: Math.round((c.x + p.x) / gridSize) * gridSize, y: Math.round((c.y + p.y) / gridSize) * gridSize };
        }

        function getPinDir(pinId) {
            const cId = pinId.substring(0, pinId.lastIndexOf('_'));
            const pId = pinId.substring(pinId.lastIndexOf('_') + 1);
            const comp = components.find(c => c.id === cId);
            if(!comp) return {x: 1, y: 0};
            const pin = comp.def.pins.find(p => p.id === pId);
            if(pin && pin.dir) return pin.dir;
            if(pin && pin.x < comp.def.width / 2) return {x: -1, y: 0};
            return {x: 1, y: 0};
        }

        function findAStarPath(start, end) {
            const gridStart = {x: Math.round(start.x/gridSize), y: Math.round(start.y/gridSize)};
            const gridEnd = {x: Math.round(end.x/gridSize), y: Math.round(end.y/gridSize)};

            if(gridStart.x === gridEnd.x && gridStart.y === gridEnd.y) return [start];

            let minX = Math.min(gridStart.x, gridEnd.x) - 10;
            let maxX = Math.max(gridStart.x, gridEnd.x) + 10;
            let minY = Math.min(gridStart.y, gridEnd.y) - 10;
            let maxY = Math.max(gridStart.y, gridEnd.y) + 10;

            const isObstacle = (x, y) => {
                return components.some(c => {
                    let cx = c.x / gridSize;
                    let cy = c.y / gridSize;
                    let cw = c.def.width / gridSize;
                    let ch = c.def.height / gridSize;
                    return x > cx && x < cx + cw && y > cy && y < cy + ch;
                });
            };

            let openSet = [gridStart];
            let cameFrom = new Map();
            let gScore = new Map();
            let fScore = new Map();
            
            const hash = (p) => `${p.x},${p.y}`;
            gScore.set(hash(gridStart), 0);
            fScore.set(hash(gridStart), Math.abs(gridStart.x - gridEnd.x) + Math.abs(gridStart.y - gridEnd.y));

            const dirs = [{x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0}];
            let iter = 0;

            while(openSet.length > 0 && iter < 3000) {
                iter++;
                let currIdx = 0;
                let minF = fScore.get(hash(openSet[0]));
                for(let i=1; i<openSet.length; i++) {
                    let f = fScore.get(hash(openSet[i]));
                    if(f < minF) { minF = f; currIdx = i; }
                }

                let current = openSet.splice(currIdx, 1)[0];
                let currentHash = hash(current);

                if (current.x === gridEnd.x && current.y === gridEnd.y) {
                    let path = [current];
                    while(cameFrom.has(hash(path[0]))) {
                        path.unshift(cameFrom.get(hash(path[0])));
                    }
                    let simplifiedPath = [path[0]];
                    let lastDir = null;
                    for(let i=1; i<path.length; i++){
                        let dx = path[i].x - path[i-1].x;
                        let dy = path[i].y - path[i-1].y;
                        if(lastDir && (lastDir.x !== dx || lastDir.y !== dy)) {
                            simplifiedPath.push(path[i-1]);
                        }
                        lastDir = {x: dx, y: dy};
                    }
                    simplifiedPath.push(path[path.length-1]);
                    return simplifiedPath.map(p => ({x: p.x * gridSize, y: p.y * gridSize}));
                }

                for(let dir of dirs) {
                    let neighbor = {x: current.x + dir.x, y: current.y + dir.y};
                    if(neighbor.x < minX || neighbor.x > maxX || neighbor.y < minY || neighbor.y > maxY) continue;

                    let moveCost = isObstacle(neighbor.x, neighbor.y) ? 100 : 1;
                    let turnPenalty = 0;
                    if (cameFrom.has(currentHash)) {
                        let prev = cameFrom.get(currentHash);
                        let prevDir = {x: current.x - prev.x, y: current.y - prev.y};
                        if (prevDir.x !== dir.x || prevDir.y !== dir.y) turnPenalty = 5; 
                    }

                    let t_gScore = gScore.get(currentHash) + moveCost + turnPenalty;
                    let neighborHash = hash(neighbor);

                    if (!gScore.has(neighborHash) || t_gScore < gScore.get(neighborHash)) {
                        cameFrom.set(neighborHash, current);
                        gScore.set(neighborHash, t_gScore);
                        fScore.set(neighborHash, t_gScore + Math.abs(neighbor.x - gridEnd.x) + Math.abs(neighbor.y - gridEnd.y));
                        if (!openSet.some(p => p.x === neighbor.x && p.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return null;
        }

        function getPathData(p1Id, c1, p2Id, c2) {
            let dir1 = getPinDir(p1Id);
            let dir2 = p2Id ? getPinDir(p2Id) : null;

            let ext1 = {x: c1.x + dir1.x * gridSize, y: c1.y + dir1.y * gridSize};
            let ext2 = dir2 ? {x: c2.x + dir2.x * gridSize, y: c2.y + dir2.y * gridSize} : {x: Math.round(c2.x/gridSize)*gridSize, y: Math.round(c2.y/gridSize)*gridSize};

            let path = findAStarPath(ext1, ext2);
            if (!path) {
                let midX = Math.round((ext1.x + ext2.x) / 2 / gridSize) * gridSize;
                path = [ext1, {x: midX, y: ext1.y}, {x: midX, y: ext2.y}, ext2];
            }
            
            path.unshift(c1);
            if(dir2) path.push(c2); else path.push({x: c2.x, y: c2.y}); 

            let d = `M ${path[0].x} ${path[0].y}`;
            for(let i=1; i<path.length; i++) {
                d += ` L ${path[i].x} ${path[i].y}`;
            }
            return d;
        }

        function renderWires() {
            layerWires.innerHTML = '';
            wires.forEach(wire => {
                const c1 = getPinCoords(wire.p1);
                const c2 = getPinCoords(wire.p2);
                
                const pathData = getPathData(wire.p1, c1, wire.p2, c2);

                const wireGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                wireGroup.setAttribute('class', `wire-group-${wire.id}`);
                
                const clickArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                clickArea.setAttribute('d', pathData);
                clickArea.setAttribute('class', 'wire-click-area');
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('class', 'wire');
                
                let wireHoldTimer = null;
                let holdingThisWire = false;

                const startWireHold = (e) => {
                    if(isSimulating) return;
                    holdingThisWire = false;
                    wireTouchStartPt = getEventPoint(e);
                    wireHoldTimer = setTimeout(() => {
                        holdingThisWire = true;
                        isHoldingWire = true;
                        isDraggingCanvas = false; 
                        draggingWireId = wire.id;
                        trashCan.classList.add('visible');
                        path.style.stroke = '#dc3545';
                        path.style.strokeDasharray = '5,5';
                        path.style.strokeWidth = '4'; 
                        if (navigator.vibrate) navigator.vibrate(50);
                    }, 300);
                };

                const cancelWireHold = () => {
                    if(wireHoldTimer) clearTimeout(wireHoldTimer);
                    wireHoldTimer = null;
                    holdingThisWire = false;
                };

                const handleWireMove = (e) => {
                    if(!holdingThisWire && wireHoldTimer && wireTouchStartPt) {
                        const pt = getEventPoint(e);
                        const dist = Math.hypot(pt.x - wireTouchStartPt.x, pt.y - wireTouchStartPt.y);
                        if(dist > 10) { 
                            clearTimeout(wireHoldTimer);
                            wireHoldTimer = null;
                        }
                    }
                };

                clickArea.addEventListener('mousedown', startWireHold);
                clickArea.addEventListener('touchstart', startWireHold, {passive: true});
                
                clickArea.addEventListener('mouseup', cancelWireHold);
                clickArea.addEventListener('touchend', cancelWireHold);
                
                clickArea.addEventListener('touchmove', handleWireMove, {passive: true});
                clickArea.addEventListener('mousemove', handleWireMove);
                
                wireGroup.appendChild(clickArea);
                wireGroup.appendChild(path);
                layerWires.appendChild(wireGroup);
            });

            if (tempWire) {
                const pathData = getPathData(tempWire.p1, {x: tempWire.startX, y: tempWire.startY}, tempWire.snapPin, {x: tempWire.endX, y: tempWire.endY});
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('class', 'wire');
                path.style.strokeDasharray = '5,5';
                path.style.pointerEvents = 'none';
                path.style.opacity = '0.7';
                layerWires.appendChild(path);
            }
        }

        function getEventPoint(e) {
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        function screenToWorld(screenX, screenY) {
            const rect = canvasContainer.getBoundingClientRect();
            return {
                x: (screenX - rect.left - canvasOffset.x) / canvasScale,
                y: (screenY - rect.top - canvasOffset.y) / canvasScale
            };
        }

        function handleDragStart(e) {
            if(isSimulating) return;

            if (e.target.classList && e.target.classList.contains('terminal')) {
                e.stopPropagation(); 
                const pinId = e.target.getAttribute('data-pinid');
                const startCoords = getPinCoords(pinId);
                
                tempWire = {
                    p1: pinId, startX: startCoords.x, startY: startCoords.y,
                    endX: startCoords.x, endY: startCoords.y, snapPin: null
                };

                allPinsCache = [];
                const sourceCompId = pinId.substring(0, pinId.lastIndexOf('_'));
                components.forEach(c => {
                    if(c.id === sourceCompId) return;
                    c.def.pins.forEach(p => {
                        const pid = `${c.id}_${p.id}`;
                        allPinsCache.push({
                            id: pid, coords: getPinCoords(pid),
                            element: document.querySelector(`[data-pinid="${pid}"]`)
                        });
                    });
                });
                return;
            }

            const target = e.target.closest ? e.target.closest('.component-group') : null;
            if (target && !e.target.classList.contains('terminal')) {
                const id = target.getAttribute('data-id');
                draggingComp = components.find(c => c.id === id);
                if (draggingComp) {
                    const pt = getEventPoint(e);
                    const world = screenToWorld(pt.x, pt.y);
                    dragOffset.x = world.x - draggingComp.x;
                    dragOffset.y = world.y - draggingComp.y;
                    trashCan.classList.add('visible'); 
                }
            }
        }

        function handleDragMove(e) {
            if (isHoldingWire) {
                e.preventDefault();
                const pt = getEventPoint(e);
                const trashRect = trashCan.getBoundingClientRect();
                if (pt.x > trashRect.left && pt.x < trashRect.right && pt.y > trashRect.top && pt.y < trashRect.bottom) {
                    trashCan.classList.add('active'); isHoveringTrash = true;
                } else {
                    trashCan.classList.remove('active'); isHoveringTrash = false;
                }
                
                if (wireTouchStartPt) {
                    const world = screenToWorld(pt.x, pt.y);
                    const worldStart = screenToWorld(wireTouchStartPt.x, wireTouchStartPt.y);
                    const dx = world.x - worldStart.x;
                    const dy = world.y - worldStart.y;
                    const wg = document.querySelector(`.wire-group-${draggingWireId}`);
                    if (wg) wg.setAttribute('transform', `translate(${dx}, ${dy})`);
                }
                return;
            }

            if (!tempWire && !draggingComp) return;
            e.preventDefault();
            
            if (tempWire) {
                const pt = getEventPoint(e);
                const world = screenToWorld(pt.x, pt.y);
                let minDist = 30 / canvasScale;
                let closestPin = null;

                allPinsCache.forEach(p => {
                    if(p.element) p.element.classList.remove('active');
                    let dx = world.x - p.coords.x;
                    let dy = world.y - p.coords.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < minDist) { minDist = dist; closestPin = p; }
                });

                if (closestPin) {
                    tempWire.endX = closestPin.coords.x; tempWire.endY = closestPin.coords.y;
                    tempWire.snapPin = closestPin.id;
                    if(closestPin.element) closestPin.element.classList.add('active');
                } else {
                    tempWire.endX = world.x; tempWire.endY = world.y;
                    tempWire.snapPin = null;
                }
                renderWires();
                return;
            }

            if (draggingComp) {
                const pt = getEventPoint(e);
                const world = screenToWorld(pt.x, pt.y);
                const trashRect = trashCan.getBoundingClientRect();
                if (pt.x > trashRect.left && pt.x < trashRect.right && pt.y > trashRect.top && pt.y < trashRect.bottom) {
                    trashCan.classList.add('active'); isHoveringTrash = true;
                } else {
                    trashCan.classList.remove('active'); isHoveringTrash = false;
                }

                let pinOffsetX = draggingComp.def.pins[0].x;
                let pinOffsetY = draggingComp.def.pins[0].y;
                let rawX = world.x - dragOffset.x;
                let rawY = world.y - dragOffset.y;
                let snapX = Math.round((rawX + pinOffsetX) / gridSize) * gridSize - pinOffsetX;
                let snapY = Math.round((rawY + pinOffsetY) / gridSize) * gridSize - pinOffsetY;
                
                draggingComp.x = snapX; draggingComp.y = snapY;
                const compGroup = document.querySelector(`g[data-id="${draggingComp.id}"]`);
                if (compGroup) compGroup.setAttribute('transform', `translate(${draggingComp.x}, ${draggingComp.y})`);
                renderWires();
            }
        }

        function handleDragEnd(e) {
            if (isHoldingWire) {
                if (isHoveringTrash) {
                    wires = wires.filter(w => w.id !== draggingWireId);
                }
                isHoldingWire = false;
                draggingWireId = null;
                isHoveringTrash = false;
                trashCan.classList.remove('visible', 'active');
                renderWires();
                return;
            }

            if (tempWire) {
                allPinsCache.forEach(p => { if(p.element) p.element.classList.remove('active'); });
                if (tempWire.snapPin) {
                    const fromComp = tempWire.p1.substring(0, tempWire.p1.lastIndexOf('_'));
                    const toComp = tempWire.snapPin.substring(0, tempWire.snapPin.lastIndexOf('_'));
                    const sameComp = fromComp === toComp;
                    const exist = wires.find(w => (w.p1 === tempWire.p1 && w.p2 === tempWire.snapPin) || (w.p2 === tempWire.p1 && w.p1 === tempWire.snapPin));
                    if(!exist && !sameComp) wires.push({ id: 'w_'+Date.now(), p1: tempWire.p1, p2: tempWire.snapPin });
                }
                tempWire = null; allPinsCache = [];
                renderWires();
                return;
            }

            if (draggingComp) {
                if (isHoveringTrash) {
                    components = components.filter(c => c.id !== draggingComp.id);
                    wires = wires.filter(w => !w.p1.startsWith(draggingComp.id) && !w.p2.startsWith(draggingComp.id));
                }
                draggingComp = null; isHoveringTrash = false;
                trashCan.classList.remove('visible', 'active');
                renderComponents(); renderWires();
            }
        }

        function resetCanvas(silent = false) {
            if(silent || confirm("ç¡®å®šæ¸…ç©ºç”»å¸ƒå¹¶é‡ç½®å—ï¼Ÿ")) {
                components = []; wires = []; compCounter = 0;
                resetSimulation(); renderComponents(); renderWires();
                if(document.getElementById('practice-result')) {
                    document.getElementById('practice-result').innerText = '';
                }
            }
        }

        function resetSimulation() {
            isSimulating = false;
            conductingWireIds = new Set();
            document.getElementById('btn-simulate').innerText = "å¯åŠ¨å®éªŒ";
            document.getElementById('btn-simulate').classList.replace('btn-warning', 'btn-primary');
            setStatus('idle', document.getElementById('scene-select').value === 'practice' ? 'ç›®æ ‡ä»»åŠ¡æ¨¡å¼ï¼šè¯·æ ¹æ®æç¤ºè¿æ¥ç”µè·¯ã€‚' : 'ç­‰å¾…æ“ä½œ (æœªè¿æ¥ç”µæº)');
            document.querySelectorAll('.bulb-glass, .bulb-cross').forEach(el => el.classList.remove('active'));
            // Reset meter readings text
            components.forEach(c => {
                const compGroup = document.querySelector(`g[data-id="${c.id}"]`);
                if(compGroup) {
                    const meterText = compGroup.querySelector('.meter-reading');
                    if(meterText) {
                        if(c.type === 'ammeter') { meterText.textContent = '0.00A'; meterText.setAttribute('fill', '#6c757d'); }
                        else if(c.type === 'voltmeter') { meterText.textContent = '0.00V'; meterText.setAttribute('fill', '#6c757d'); }
                        else if(c.type.startsWith('battery')) { meterText.textContent = c.def.voltage.toFixed(1) + 'V'; }
                    }
                }
            });
            renderWires();
        }

        function toggleSimulation() {
            if(isSimulating) {
                resetSimulation();
            } else {
                isSimulating = true;
                renderComponents();
                document.getElementById('btn-simulate').innerText = "åœæ­¢å®éªŒ";
                document.getElementById('btn-simulate').classList.replace('btn-primary', 'btn-warning');
                updateSimulation();
            }
        }

        function setStatus(type, text) {
            statusDisplay.className = `status-box status-${type}`;
            statusDisplay.innerText = text;
        }

        function buildGraph(opts = {}) {
            let graph = {};
            const addEdge = (u, v, res, comp = null) => {
                if(!graph[u]) graph[u] = []; if(!graph[v]) graph[v] = [];
                graph[u].push({to: v, res: res, comp: comp}); graph[v].push({to: u, res: res, comp: comp});
            };

            components.forEach(c => {
                if(c.type.startsWith('battery')) return;
                const p1 = `${c.id}_p1`, p2 = `${c.id}_p2`;
                let res = c.def.res;
                if(c.type === 'switch') res = (opts.forceSwitchesClosed || c.isClosed) ? 0 : 999999;
                if(opts.applianceShort && (c.type === 'bulb' || c.type === 'resistor')) res = 0;
                addEdge(p1, p2, res, c);
            });

            let effectiveWires = opts.breakWireIndex !== undefined && opts.breakWireIndex >= 0 && opts.breakWireIndex < wires.length ? 
                wires.filter((_, i) => i !== opts.breakWireIndex) : wires;
            effectiveWires.forEach(w => addEdge(w.p1, w.p2, 0, null));

            if(opts.powerShort) {
                const battery = components.find(c => c.type.startsWith('battery'));
                if(battery) addEdge(`${battery.id}_p1`, `${battery.id}_p2`, 0, null);
            }
            return { graph, addEdge };
        }

        function dijkstra(graph, startPin, endPin) {
            let dist = {}, prev = {};
            for(let node in graph) dist[node] = Infinity;
            dist[startPin] = 0;
            let pq = [startPin], visited = {};
            while(pq.length > 0) {
                pq.sort((a,b) => dist[a] - dist[b]);
                let u = pq.shift();
                if(visited[u]) continue;
                visited[u] = true;
                if(!graph[u]) continue;
                for(let edge of graph[u]) {
                    let alt = dist[u] + edge.res;
                    if(alt < dist[edge.to]) {
                        dist[edge.to] = alt;
                        prev[edge.to] = { from: u, comp: edge.comp };
                        pq.push(edge.to);
                    }
                }
            }
            return { dist, prev };
        }

        function findAllConductingComps(graph, startPin, endPin) {
            let workingGraph = {};
            let degrees = {};
            let validEdges = [];

            for(let node in graph) degrees[node] = 0;

            for (let u in graph) {
                workingGraph[u] = [];
                for (let edge of graph[u]) {
                    if (edge.res < 999999) {
                        workingGraph[u].push({...edge});
                        degrees[u]++;
                        if (u < edge.to) {
                            validEdges.push({u: u, v: edge.to, comp: edge.comp});
                        }
                    }
                }
            }

            let queue = [];
            for (let node in degrees) {
                if (degrees[node] === 1 && node !== startPin && node !== endPin) {
                    queue.push(node);
                }
            }

            let removedNodes = new Set();
            
            while (queue.length > 0) {
                let u = queue.shift();
                if (removedNodes.has(u)) continue;
                removedNodes.add(u);
                degrees[u] = 0;

                for (let edge of workingGraph[u]) {
                    let v = edge.to;
                    if (!removedNodes.has(v)) {
                        degrees[v]--;
                        if (degrees[v] === 1 && v !== startPin && v !== endPin) {
                            queue.push(v);
                        }
                    }
                }
            }

            let reachable = new Set();
            let bfsQueue = [startPin];
            reachable.add(startPin);

            while (bfsQueue.length > 0) {
                let u = bfsQueue.shift();
                if(removedNodes.has(u)) continue; 

                for (let edge of workingGraph[u]) {
                    let v = edge.to;
                    if (!removedNodes.has(v) && !reachable.has(v)) {
                        reachable.add(v);
                        bfsQueue.push(v);
                    }
                }
            }

            let conductingComps = new Set();
            let conductingEdges = new Set();
            let hasLoad = false;

            for (let e of validEdges) {
                if (!removedNodes.has(e.u) && !removedNodes.has(e.v) && reachable.has(e.u) && reachable.has(e.v)) {
                    conductingEdges.add(e.u + '|' + e.v);
                    conductingEdges.add(e.v + '|' + e.u);
                    if (e.comp) {
                        conductingComps.add(e.comp);
                        if (e.comp.type === 'bulb' || e.comp.type === 'resistor') {
                            hasLoad = true;
                        }
                    }
                }
            }

            let { dist } = dijkstra(graph, startPin, endPin);
            return { comps: conductingComps, wireEdges: conductingEdges, totalRes: dist[endPin], hasLoad };
        }

        function updateSimulation() {
            const battery = components.find(c => c.type.startsWith('battery'));
            if(!battery) return setStatus('error', 'æœªæ£€æµ‹åˆ°ç”µæºï¼Œç”µè·¯æ–­è·¯ã€‚');
            const batVoltage = battery.def.voltage;

            const batP1 = `${battery.id}_p1`, batP2 = `${battery.id}_p2`;
            
            let { graph } = buildGraph({});
            if(!graph[batP1]) graph[batP1] = []; if(!graph[batP2]) graph[batP2] = [];
            let { dist } = dijkstra(graph, batP1, batP2);
            let totalRes = dist[batP2];

            document.querySelectorAll('.bulb-glass, .bulb-cross').forEach(el => el.classList.remove('active'));
            conductingWireIds = new Set();

            // Readings update logic
            let I_global = 0;
            if (totalRes > 0 && totalRes < 999999) {
                I_global = batVoltage / totalRes;
            } else if (totalRes === 0) {
                I_global = Infinity;
            }

            let conductingComps = new Set();
            if(totalRes < 999999) {
                const res = findAllConductingComps(graph, batP1, batP2);
                conductingComps = res.comps;
                conductingWireIds = findConductingWiresAll(graph, batP1, batP2);
            }

            components.forEach(c => {
                const compGroup = document.querySelector(`g[data-id="${c.id}"]`);
                if(!compGroup) return;
                const meterText = compGroup.querySelector('.meter-reading');
                if(!meterText) return;

                if (c.type === 'ammeter') {
                    if (totalRes >= 999999 || !conductingComps.has(c)) {
                        meterText.textContent = '0.00A';
                        meterText.setAttribute('fill', '#6c757d');
                    } else if (totalRes === 0) {
                        meterText.textContent = 'ERR';
                        meterText.setAttribute('fill', '#dc3545');
                    } else {
                        meterText.textContent = (I_global > 9.99 ? '>9.9A' : I_global.toFixed(2) + 'A');
                        meterText.setAttribute('fill', '#0d6efd');
                    }
                } else if (c.type === 'voltmeter') {
                    let cp1 = `${c.id}_p1`, cp2 = `${c.id}_p2`;
                    let d1 = dist[cp1] !== undefined ? dist[cp1] : Infinity;
                    let d2 = dist[cp2] !== undefined ? dist[cp2] : Infinity;
                    
                    if (totalRes >= 999999) {
                        let { graph: fullGraph } = buildGraph({ forceSwitchesClosed: false });
                        let batDistP1 = dijkstra(fullGraph, batP1, cp1).dist[cp1];
                        let batDistP2 = dijkstra(fullGraph, batP2, cp2).dist[cp2];
                        let batDistP1_alt = dijkstra(fullGraph, batP1, cp2).dist[cp2];
                        let batDistP2_alt = dijkstra(fullGraph, batP2, cp1).dist[cp1];

                        if ((batDistP1 < 999999 && batDistP2 < 999999) || (batDistP1_alt < 999999 && batDistP2_alt < 999999)) {
                            meterText.textContent = batVoltage.toFixed(2) + 'V'; 
                            meterText.setAttribute('fill', '#0d6efd');
                        } else {
                            meterText.textContent = '0.00V';
                            meterText.setAttribute('fill', '#6c757d');
                        }
                    } else {
                        let v1 = batVoltage * (1 - (d1 / totalRes));
                        let v2 = batVoltage * (1 - (d2 / totalRes));
                        let vDiff = Math.abs(v1 - v2);
                        if(isNaN(vDiff)) vDiff = 0;
                        meterText.textContent = vDiff.toFixed(2) + 'V';
                        meterText.setAttribute('fill', '#0d6efd');
                    }
                }
            });

            // Status Updates
            if(totalRes >= 999999) { 
                renderWires(); 
                setStatus('idle', 'çŠ¶æ€: æ–­è·¯ (å¼€å…³æœªé—­åˆæˆ–çº¿è·¯æœªè¿é€š)'); 
            }
            else if(totalRes === 0) {
                let allResult = findAllConductingComps(graph, batP1, batP2);
                if(!allResult.hasLoad) { 
                    renderWires(); 
                    setStatus('error', 'âš ï¸ è­¦å‘Š: ç”µæºçŸ­è·¯ï¼è¯·ç«‹å³æ–­å¼€å¼€å…³ã€‚'); 
                }
                else { 
                    renderWires(); 
                    setStatus('error', 'âš ï¸ ç”¨ç”µå™¨è¢«çŸ­è·¯ï¼æœ‰å¯¼çº¿ç›´æ¥ç»•è¿‡äº†ç”¨ç”µå™¨ã€‚'); 
                }
            } else {
                lightBulbsAll(graph, batP1, batP2); 
                renderWires();
                setStatus('success', 'çŠ¶æ€: å¯¼é€šã€‚å®éªŒæ­£å¸¸è¿›è¡Œã€‚');
            }

            if(document.getElementById('scene-select').value === 'practice') {
                const resDiv = document.getElementById('practice-result');
                if (resDiv.innerHTML.includes('å¤±è´¥')) resDiv.innerHTML = '';
            }
        }

        function lightBulbsAll(graph, startPin, endPin) {
            let result = findAllConductingComps(graph, startPin, endPin);
            for(let comp of result.comps) {
                if(comp.type === 'bulb') {
                    const compGroup = document.querySelector(`g[data-id="${comp.id}"]`);
                    if(compGroup) {
                        compGroup.querySelector('.bulb-glass').classList.add('active');
                        let cross = compGroup.querySelector('.bulb-cross');
                        if(cross) cross.classList.add('active');
                    }
                }
            }
        }

        function findConductingWiresAll(graph, startPin, endPin) {
            let result = findAllConductingComps(graph, startPin, endPin);
            let ids = new Set();
            wires.forEach(w => {
                if(result.wireEdges.has(w.p1 + '|' + w.p2) || result.wireEdges.has(w.p2 + '|' + w.p1)) ids.add(w.id);
            });
            return ids;
        }
    </script>
</body>
</html>